#include "c.h"
#define NODEPTR_TYPE Node
#define OP_LABEL(p) ((p)->op)
#define LEFT_CHILD(p) ((p)->x.kids[0])
#define RIGHT_CHILD(p) ((p)->x.kids[1])
#define STATE_LABEL(p) ((p)->x.state)
#define PANIC print

#define ALLOC(n) (talloc(n))
#ifndef ALLOC
#define ALLOC(n) malloc(n)
#endif
#ifdef __STDC__
#define CHECK(a,b) if(!(a)){extern void abort(void);b;abort();}
#else
#define CHECK(a,b) if(!(a)){extern void abort();b;abort();}
#endif

#define sparc_stmt_NT 1
#define sparc_acon_NT 2
#define sparc_addr_NT 3
#define sparc_ar_NT 4
#define sparc_con_NT 5
#define sparc_rc_NT 6
#define sparc_reg_NT 7

char *sparc_ntname[] = {
	0,
	"stmt",
	"acon",
	"addr",
	"ar",
	"con",
	"rc",
	"reg",
	0
};

char sparc_arity[] = {
	0,
	0,  /* 1 */
	0,  /* 2 */
	0,  /* 3 */
	0,  /* 4 */
	0,  /* 5 */
	0,  /* 6 */
	0,  /* 7 */
	0,  /* 8 */
	0,  /* 9 */
	0,  /* 10 */
	0,  /* 11 */
	0,  /* 12 */
	0,  /* 13 */
	0,  /* 14 */
	0,  /* 15 */
	0,  /* 16 */
	0,  /* 17=CNSTF */
	0,  /* 18=CNSTD */
	0,  /* 19=CNSTC */
	0,  /* 20=CNSTS */
	0,  /* 21=CNSTI */
	0,  /* 22=CNSTU */
	0,  /* 23=CNSTP */
	0,  /* 24 */
	0,  /* 25 */
	0,  /* 26 */
	0,  /* 27 */
	0,  /* 28 */
	0,  /* 29 */
	0,  /* 30 */
	0,  /* 31 */
	0,  /* 32 */
	1,  /* 33=ARGF */
	1,  /* 34=ARGD */
	0,  /* 35 */
	0,  /* 36 */
	1,  /* 37=ARGI */
	0,  /* 38 */
	1,  /* 39=ARGP */
	0,  /* 40 */
	0,  /* 41=ARGB */
	0,  /* 42 */
	0,  /* 43 */
	0,  /* 44 */
	0,  /* 45 */
	0,  /* 46 */
	0,  /* 47 */
	0,  /* 48 */
	2,  /* 49=ASGNF */
	2,  /* 50=ASGND */
	2,  /* 51=ASGNC */
	2,  /* 52=ASGNS */
	2,  /* 53=ASGNI */
	0,  /* 54 */
	2,  /* 55=ASGNP */
	0,  /* 56 */
	2,  /* 57=ASGNB */
	0,  /* 58 */
	0,  /* 59 */
	0,  /* 60 */
	0,  /* 61 */
	0,  /* 62 */
	0,  /* 63 */
	0,  /* 64 */
	1,  /* 65=INDIRF */
	1,  /* 66=INDIRD */
	1,  /* 67=INDIRC */
	1,  /* 68=INDIRS */
	1,  /* 69=INDIRI */
	0,  /* 70 */
	1,  /* 71=INDIRP */
	0,  /* 72 */
	1,  /* 73=INDIRB */
	0,  /* 74 */
	0,  /* 75 */
	0,  /* 76 */
	0,  /* 77 */
	0,  /* 78 */
	0,  /* 79 */
	0,  /* 80 */
	0,  /* 81 */
	0,  /* 82 */
	0,  /* 83 */
	0,  /* 84 */
	1,  /* 85=CVCI */
	1,  /* 86=CVCU */
	0,  /* 87 */
	0,  /* 88 */
	0,  /* 89 */
	0,  /* 90 */
	0,  /* 91 */
	0,  /* 92 */
	0,  /* 93 */
	0,  /* 94 */
	0,  /* 95 */
	0,  /* 96 */
	1,  /* 97=CVDF */
	0,  /* 98 */
	0,  /* 99 */
	0,  /* 100 */
	1,  /* 101=CVDI */
	0,  /* 102 */
	0,  /* 103 */
	0,  /* 104 */
	0,  /* 105 */
	0,  /* 106 */
	0,  /* 107 */
	0,  /* 108 */
	0,  /* 109 */
	0,  /* 110 */
	0,  /* 111 */
	0,  /* 112 */
	0,  /* 113 */
	1,  /* 114=CVFD */
	0,  /* 115 */
	0,  /* 116 */
	0,  /* 117 */
	0,  /* 118 */
	0,  /* 119 */
	0,  /* 120 */
	0,  /* 121 */
	0,  /* 122 */
	0,  /* 123 */
	0,  /* 124 */
	0,  /* 125 */
	0,  /* 126 */
	0,  /* 127 */
	0,  /* 128 */
	0,  /* 129 */
	1,  /* 130=CVID */
	1,  /* 131=CVIC */
	1,  /* 132=CVIS */
	0,  /* 133 */
	1,  /* 134=CVIU */
	0,  /* 135 */
	0,  /* 136 */
	0,  /* 137 */
	0,  /* 138 */
	0,  /* 139 */
	0,  /* 140 */
	0,  /* 141 */
	0,  /* 142 */
	0,  /* 143 */
	0,  /* 144 */
	0,  /* 145 */
	0,  /* 146 */
	0,  /* 147 */
	0,  /* 148 */
	0,  /* 149 */
	1,  /* 150=CVPU */
	0,  /* 151 */
	0,  /* 152 */
	0,  /* 153 */
	0,  /* 154 */
	0,  /* 155 */
	0,  /* 156 */
	0,  /* 157 */
	0,  /* 158 */
	0,  /* 159 */
	0,  /* 160 */
	0,  /* 161 */
	0,  /* 162 */
	0,  /* 163 */
	0,  /* 164 */
	1,  /* 165=CVSI */
	1,  /* 166=CVSU */
	0,  /* 167 */
	0,  /* 168 */
	0,  /* 169 */
	0,  /* 170 */
	0,  /* 171 */
	0,  /* 172 */
	0,  /* 173 */
	0,  /* 174 */
	0,  /* 175 */
	0,  /* 176 */
	0,  /* 177 */
	0,  /* 178 */
	1,  /* 179=CVUC */
	1,  /* 180=CVUS */
	1,  /* 181=CVUI */
	0,  /* 182 */
	1,  /* 183=CVUP */
	0,  /* 184 */
	0,  /* 185 */
	0,  /* 186 */
	0,  /* 187 */
	0,  /* 188 */
	0,  /* 189 */
	0,  /* 190 */
	0,  /* 191 */
	0,  /* 192 */
	1,  /* 193=NEGF */
	1,  /* 194=NEGD */
	0,  /* 195 */
	0,  /* 196 */
	1,  /* 197=NEGI */
	0,  /* 198 */
	0,  /* 199 */
	0,  /* 200 */
	0,  /* 201 */
	0,  /* 202 */
	0,  /* 203 */
	0,  /* 204 */
	0,  /* 205 */
	0,  /* 206 */
	0,  /* 207 */
	0,  /* 208 */
	1,  /* 209=CALLF */
	1,  /* 210=CALLD */
	0,  /* 211 */
	0,  /* 212 */
	1,  /* 213=CALLI */
	0,  /* 214 */
	0,  /* 215 */
	1,  /* 216=CALLV */
	2,  /* 217=CALLB */
	0,  /* 218 */
	0,  /* 219 */
	0,  /* 220 */
	0,  /* 221 */
	0,  /* 222 */
	0,  /* 223 */
	0,  /* 224 */
	1,  /* 225=LOADF */
	1,  /* 226=LOADD */
	1,  /* 227=LOADC */
	1,  /* 228=LOADS */
	1,  /* 229=LOADI */
	1,  /* 230=LOADU */
	1,  /* 231=LOADP */
	0,  /* 232 */
	1,  /* 233=LOADB */
	0,  /* 234 */
	0,  /* 235 */
	0,  /* 236 */
	0,  /* 237 */
	0,  /* 238 */
	0,  /* 239 */
	0,  /* 240 */
	1,  /* 241=RETF */
	1,  /* 242=RETD */
	0,  /* 243 */
	0,  /* 244 */
	1,  /* 245=RETI */
	0,  /* 246 */
	0,  /* 247 */
	0,  /* 248=RETV */
	0,  /* 249 */
	0,  /* 250 */
	0,  /* 251 */
	0,  /* 252 */
	0,  /* 253 */
	0,  /* 254 */
	0,  /* 255 */
	0,  /* 256 */
	0,  /* 257 */
	0,  /* 258 */
	0,  /* 259 */
	0,  /* 260 */
	0,  /* 261 */
	0,  /* 262 */
	0,  /* 263=ADDRGP */
	0,  /* 264 */
	0,  /* 265 */
	0,  /* 266 */
	0,  /* 267 */
	0,  /* 268 */
	0,  /* 269 */
	0,  /* 270 */
	0,  /* 271 */
	0,  /* 272 */
	0,  /* 273 */
	0,  /* 274 */
	0,  /* 275 */
	0,  /* 276 */
	0,  /* 277 */
	0,  /* 278 */
	0,  /* 279=ADDRFP */
	0,  /* 280 */
	0,  /* 281 */
	0,  /* 282 */
	0,  /* 283 */
	0,  /* 284 */
	0,  /* 285 */
	0,  /* 286 */
	0,  /* 287 */
	0,  /* 288 */
	0,  /* 289 */
	0,  /* 290 */
	0,  /* 291 */
	0,  /* 292 */
	0,  /* 293 */
	0,  /* 294 */
	0,  /* 295=ADDRLP */
	0,  /* 296 */
	0,  /* 297 */
	0,  /* 298 */
	0,  /* 299 */
	0,  /* 300 */
	0,  /* 301 */
	0,  /* 302 */
	0,  /* 303 */
	0,  /* 304 */
	2,  /* 305=ADDF */
	2,  /* 306=ADDD */
	0,  /* 307 */
	0,  /* 308 */
	2,  /* 309=ADDI */
	2,  /* 310=ADDU */
	2,  /* 311=ADDP */
	0,  /* 312 */
	0,  /* 313 */
	0,  /* 314 */
	0,  /* 315 */
	0,  /* 316 */
	0,  /* 317 */
	0,  /* 318 */
	0,  /* 319 */
	0,  /* 320 */
	2,  /* 321=SUBF */
	2,  /* 322=SUBD */
	0,  /* 323 */
	0,  /* 324 */
	2,  /* 325=SUBI */
	2,  /* 326=SUBU */
	2,  /* 327=SUBP */
	0,  /* 328 */
	0,  /* 329 */
	0,  /* 330 */
	0,  /* 331 */
	0,  /* 332 */
	0,  /* 333 */
	0,  /* 334 */
	0,  /* 335 */
	0,  /* 336 */
	0,  /* 337 */
	0,  /* 338 */
	0,  /* 339 */
	0,  /* 340 */
	2,  /* 341=LSHI */
	2,  /* 342=LSHU */
	0,  /* 343 */
	0,  /* 344 */
	0,  /* 345 */
	0,  /* 346 */
	0,  /* 347 */
	0,  /* 348 */
	0,  /* 349 */
	0,  /* 350 */
	0,  /* 351 */
	0,  /* 352 */
	0,  /* 353 */
	0,  /* 354 */
	0,  /* 355 */
	0,  /* 356 */
	2,  /* 357=MODI */
	2,  /* 358=MODU */
	0,  /* 359 */
	0,  /* 360 */
	0,  /* 361 */
	0,  /* 362 */
	0,  /* 363 */
	0,  /* 364 */
	0,  /* 365 */
	0,  /* 366 */
	0,  /* 367 */
	0,  /* 368 */
	0,  /* 369 */
	0,  /* 370 */
	0,  /* 371 */
	0,  /* 372 */
	2,  /* 373=RSHI */
	2,  /* 374=RSHU */
	0,  /* 375 */
	0,  /* 376 */
	0,  /* 377 */
	0,  /* 378 */
	0,  /* 379 */
	0,  /* 380 */
	0,  /* 381 */
	0,  /* 382 */
	0,  /* 383 */
	0,  /* 384 */
	0,  /* 385 */
	0,  /* 386 */
	0,  /* 387 */
	0,  /* 388 */
	0,  /* 389 */
	2,  /* 390=BANDU */
	0,  /* 391 */
	0,  /* 392 */
	0,  /* 393 */
	0,  /* 394 */
	0,  /* 395 */
	0,  /* 396 */
	0,  /* 397 */
	0,  /* 398 */
	0,  /* 399 */
	0,  /* 400 */
	0,  /* 401 */
	0,  /* 402 */
	0,  /* 403 */
	0,  /* 404 */
	0,  /* 405 */
	1,  /* 406=BCOMU */
	0,  /* 407 */
	0,  /* 408 */
	0,  /* 409 */
	0,  /* 410 */
	0,  /* 411 */
	0,  /* 412 */
	0,  /* 413 */
	0,  /* 414 */
	0,  /* 415 */
	0,  /* 416 */
	0,  /* 417 */
	0,  /* 418 */
	0,  /* 419 */
	0,  /* 420 */
	0,  /* 421 */
	2,  /* 422=BORU */
	0,  /* 423 */
	0,  /* 424 */
	0,  /* 425 */
	0,  /* 426 */
	0,  /* 427 */
	0,  /* 428 */
	0,  /* 429 */
	0,  /* 430 */
	0,  /* 431 */
	0,  /* 432 */
	0,  /* 433 */
	0,  /* 434 */
	0,  /* 435 */
	0,  /* 436 */
	0,  /* 437 */
	2,  /* 438=BXORU */
	0,  /* 439 */
	0,  /* 440 */
	0,  /* 441 */
	0,  /* 442 */
	0,  /* 443 */
	0,  /* 444 */
	0,  /* 445 */
	0,  /* 446 */
	0,  /* 447 */
	0,  /* 448 */
	2,  /* 449=DIVF */
	2,  /* 450=DIVD */
	0,  /* 451 */
	0,  /* 452 */
	2,  /* 453=DIVI */
	2,  /* 454=DIVU */
	0,  /* 455 */
	0,  /* 456 */
	0,  /* 457 */
	0,  /* 458 */
	0,  /* 459 */
	0,  /* 460 */
	0,  /* 461 */
	0,  /* 462 */
	0,  /* 463 */
	0,  /* 464 */
	2,  /* 465=MULF */
	2,  /* 466=MULD */
	0,  /* 467 */
	0,  /* 468 */
	2,  /* 469=MULI */
	2,  /* 470=MULU */
	0,  /* 471 */
	0,  /* 472 */
	0,  /* 473 */
	0,  /* 474 */
	0,  /* 475 */
	0,  /* 476 */
	0,  /* 477 */
	0,  /* 478 */
	0,  /* 479 */
	0,  /* 480 */
	0,  /* 481=EQF */
	0,  /* 482=EQD */
	0,  /* 483 */
	0,  /* 484 */
	2,  /* 485=EQI */
	0,  /* 486 */
	0,  /* 487 */
	0,  /* 488 */
	0,  /* 489 */
	0,  /* 490 */
	0,  /* 491 */
	0,  /* 492 */
	0,  /* 493 */
	0,  /* 494 */
	0,  /* 495 */
	0,  /* 496 */
	0,  /* 497=GEF */
	0,  /* 498=GED */
	0,  /* 499 */
	0,  /* 500 */
	2,  /* 501=GEI */
	2,  /* 502=GEU */
	0,  /* 503 */
	0,  /* 504 */
	0,  /* 505 */
	0,  /* 506 */
	0,  /* 507 */
	0,  /* 508 */
	0,  /* 509 */
	0,  /* 510 */
	0,  /* 511 */
	0,  /* 512 */
	0,  /* 513=GTF */
	0,  /* 514=GTD */
	0,  /* 515 */
	0,  /* 516 */
	2,  /* 517=GTI */
	2,  /* 518=GTU */
	0,  /* 519 */
	0,  /* 520 */
	0,  /* 521 */
	0,  /* 522 */
	0,  /* 523 */
	0,  /* 524 */
	0,  /* 525 */
	0,  /* 526 */
	0,  /* 527 */
	0,  /* 528 */
	0,  /* 529=LEF */
	0,  /* 530=LED */
	0,  /* 531 */
	0,  /* 532 */
	2,  /* 533=LEI */
	2,  /* 534=LEU */
	0,  /* 535 */
	0,  /* 536 */
	0,  /* 537 */
	0,  /* 538 */
	0,  /* 539 */
	0,  /* 540 */
	0,  /* 541 */
	0,  /* 542 */
	0,  /* 543 */
	0,  /* 544 */
	0,  /* 545=LTF */
	0,  /* 546=LTD */
	0,  /* 547 */
	0,  /* 548 */
	2,  /* 549=LTI */
	2,  /* 550=LTU */
	0,  /* 551 */
	0,  /* 552 */
	0,  /* 553 */
	0,  /* 554 */
	0,  /* 555 */
	0,  /* 556 */
	0,  /* 557 */
	0,  /* 558 */
	0,  /* 559 */
	0,  /* 560 */
	0,  /* 561=NEF */
	0,  /* 562=NED */
	0,  /* 563 */
	0,  /* 564 */
	2,  /* 565=NEI */
	0,  /* 566 */
	0,  /* 567 */
	0,  /* 568 */
	0,  /* 569 */
	0,  /* 570 */
	0,  /* 571 */
	0,  /* 572 */
	0,  /* 573 */
	0,  /* 574 */
	0,  /* 575 */
	0,  /* 576 */
	0,  /* 577 */
	0,  /* 578 */
	0,  /* 579 */
	0,  /* 580 */
	0,  /* 581 */
	0,  /* 582 */
	0,  /* 583 */
	1,  /* 584=JUMPV */
	0,  /* 585 */
	0,  /* 586 */
	0,  /* 587 */
	0,  /* 588 */
	0,  /* 589 */
	0,  /* 590 */
	0,  /* 591 */
	0,  /* 592 */
	0,  /* 593 */
	0,  /* 594 */
	0,  /* 595 */
	0,  /* 596 */
	0,  /* 597 */
	0,  /* 598 */
	0,  /* 599 */
	0,  /* 600=LABELV */
	0,  /* 601 */
	0,  /* 602 */
	0,  /* 603 */
	0,  /* 604 */
	0,  /* 605 */
	0,  /* 606 */
	0,  /* 607 */
	0,  /* 608 */
	0,  /* 609 */
	0,  /* 610 */
	0,  /* 611 */
	0,  /* 612 */
	0,  /* 613 */
	0,  /* 614 */
	0,  /* 615=VREGP */
	0,  /* 616 */
	0,  /* 617 */
	0,  /* 618 */
	0,  /* 619 */
	0,  /* 620 */
	0,  /* 621 */
	0,  /* 622 */
	0,  /* 623 */
	0,  /* 624 */
	0,  /* 625 */
	0,  /* 626 */
	0,  /* 627 */
	0,  /* 628 */
	0,  /* 629 */
	0,  /* 630 */
	0,  /* 631 */
	0,  /* 632 */
	0,  /* 633 */
	0,  /* 634 */
	0,  /* 635 */
	0,  /* 636 */
	0,  /* 637 */
	0,  /* 638 */
	0,  /* 639 */
	0,  /* 640 */
	0,  /* 641 */
	0,  /* 642 */
	0,  /* 643 */
	0,  /* 644 */
	0,  /* 645 */
	0,  /* 646 */
	0,  /* 647 */
	0,  /* 648 */
	0,  /* 649 */
	0,  /* 650 */
	0,  /* 651 */
	0,  /* 652 */
	0,  /* 653 */
	0,  /* 654 */
	0,  /* 655 */
	0,  /* 656 */
	0,  /* 657 */
	0,  /* 658 */
	0,  /* 659 */
	0,  /* 660 */
	0,  /* 661=I0I */
	0,  /* 662 */
	0,  /* 663 */
	0,  /* 664 */
	0,  /* 665 */
	0,  /* 666 */
	0,  /* 667 */
	0,  /* 668 */
	0,  /* 669 */
	0,  /* 670 */
	0,  /* 671 */
	0,  /* 672 */
	0,  /* 673 */
	0,  /* 674 */
	0,  /* 675 */
	0,  /* 676 */
	0,  /* 677=I1I */
	0,  /* 678 */
	0,  /* 679 */
	0,  /* 680 */
	0,  /* 681 */
	0,  /* 682 */
	0,  /* 683 */
	0,  /* 684 */
	0,  /* 685 */
	0,  /* 686 */
	0,  /* 687 */
	0,  /* 688 */
	0,  /* 689 */
	0,  /* 690 */
	0,  /* 691 */
	0,  /* 692 */
	0,  /* 693=I2I */
	0,  /* 694 */
	0,  /* 695 */
	0,  /* 696 */
	0,  /* 697 */
	0,  /* 698 */
	0,  /* 699 */
	0,  /* 700 */
	0,  /* 701 */
	0,  /* 702 */
	0,  /* 703 */
	0,  /* 704 */
	0,  /* 705 */
	0,  /* 706 */
	0,  /* 707 */
	0,  /* 708 */
	0,  /* 709=I3I */
};

char *sparc_opname[] = {
	0,
	0,  /* 1 */
	0,  /* 2 */
	0,  /* 3 */
	0,  /* 4 */
	0,  /* 5 */
	0,  /* 6 */
	0,  /* 7 */
	0,  /* 8 */
	0,  /* 9 */
	0,  /* 10 */
	0,  /* 11 */
	0,  /* 12 */
	0,  /* 13 */
	0,  /* 14 */
	0,  /* 15 */
	0,  /* 16 */
	"CNSTF",  /* 17 */
	"CNSTD",  /* 18 */
	"CNSTC",  /* 19 */
	"CNSTS",  /* 20 */
	"CNSTI",  /* 21 */
	"CNSTU",  /* 22 */
	"CNSTP",  /* 23 */
	0,  /* 24 */
	0,  /* 25 */
	0,  /* 26 */
	0,  /* 27 */
	0,  /* 28 */
	0,  /* 29 */
	0,  /* 30 */
	0,  /* 31 */
	0,  /* 32 */
	"ARGF",  /* 33 */
	"ARGD",  /* 34 */
	0,  /* 35 */
	0,  /* 36 */
	"ARGI",  /* 37 */
	0,  /* 38 */
	"ARGP",  /* 39 */
	0,  /* 40 */
	"ARGB",  /* 41 */
	0,  /* 42 */
	0,  /* 43 */
	0,  /* 44 */
	0,  /* 45 */
	0,  /* 46 */
	0,  /* 47 */
	0,  /* 48 */
	"ASGNF",  /* 49 */
	"ASGND",  /* 50 */
	"ASGNC",  /* 51 */
	"ASGNS",  /* 52 */
	"ASGNI",  /* 53 */
	0,  /* 54 */
	"ASGNP",  /* 55 */
	0,  /* 56 */
	"ASGNB",  /* 57 */
	0,  /* 58 */
	0,  /* 59 */
	0,  /* 60 */
	0,  /* 61 */
	0,  /* 62 */
	0,  /* 63 */
	0,  /* 64 */
	"INDIRF",  /* 65 */
	"INDIRD",  /* 66 */
	"INDIRC",  /* 67 */
	"INDIRS",  /* 68 */
	"INDIRI",  /* 69 */
	0,  /* 70 */
	"INDIRP",  /* 71 */
	0,  /* 72 */
	"INDIRB",  /* 73 */
	0,  /* 74 */
	0,  /* 75 */
	0,  /* 76 */
	0,  /* 77 */
	0,  /* 78 */
	0,  /* 79 */
	0,  /* 80 */
	0,  /* 81 */
	0,  /* 82 */
	0,  /* 83 */
	0,  /* 84 */
	"CVCI",  /* 85 */
	"CVCU",  /* 86 */
	0,  /* 87 */
	0,  /* 88 */
	0,  /* 89 */
	0,  /* 90 */
	0,  /* 91 */
	0,  /* 92 */
	0,  /* 93 */
	0,  /* 94 */
	0,  /* 95 */
	0,  /* 96 */
	"CVDF",  /* 97 */
	0,  /* 98 */
	0,  /* 99 */
	0,  /* 100 */
	"CVDI",  /* 101 */
	0,  /* 102 */
	0,  /* 103 */
	0,  /* 104 */
	0,  /* 105 */
	0,  /* 106 */
	0,  /* 107 */
	0,  /* 108 */
	0,  /* 109 */
	0,  /* 110 */
	0,  /* 111 */
	0,  /* 112 */
	0,  /* 113 */
	"CVFD",  /* 114 */
	0,  /* 115 */
	0,  /* 116 */
	0,  /* 117 */
	0,  /* 118 */
	0,  /* 119 */
	0,  /* 120 */
	0,  /* 121 */
	0,  /* 122 */
	0,  /* 123 */
	0,  /* 124 */
	0,  /* 125 */
	0,  /* 126 */
	0,  /* 127 */
	0,  /* 128 */
	0,  /* 129 */
	"CVID",  /* 130 */
	"CVIC",  /* 131 */
	"CVIS",  /* 132 */
	0,  /* 133 */
	"CVIU",  /* 134 */
	0,  /* 135 */
	0,  /* 136 */
	0,  /* 137 */
	0,  /* 138 */
	0,  /* 139 */
	0,  /* 140 */
	0,  /* 141 */
	0,  /* 142 */
	0,  /* 143 */
	0,  /* 144 */
	0,  /* 145 */
	0,  /* 146 */
	0,  /* 147 */
	0,  /* 148 */
	0,  /* 149 */
	"CVPU",  /* 150 */
	0,  /* 151 */
	0,  /* 152 */
	0,  /* 153 */
	0,  /* 154 */
	0,  /* 155 */
	0,  /* 156 */
	0,  /* 157 */
	0,  /* 158 */
	0,  /* 159 */
	0,  /* 160 */
	0,  /* 161 */
	0,  /* 162 */
	0,  /* 163 */
	0,  /* 164 */
	"CVSI",  /* 165 */
	"CVSU",  /* 166 */
	0,  /* 167 */
	0,  /* 168 */
	0,  /* 169 */
	0,  /* 170 */
	0,  /* 171 */
	0,  /* 172 */
	0,  /* 173 */
	0,  /* 174 */
	0,  /* 175 */
	0,  /* 176 */
	0,  /* 177 */
	0,  /* 178 */
	"CVUC",  /* 179 */
	"CVUS",  /* 180 */
	"CVUI",  /* 181 */
	0,  /* 182 */
	"CVUP",  /* 183 */
	0,  /* 184 */
	0,  /* 185 */
	0,  /* 186 */
	0,  /* 187 */
	0,  /* 188 */
	0,  /* 189 */
	0,  /* 190 */
	0,  /* 191 */
	0,  /* 192 */
	"NEGF",  /* 193 */
	"NEGD",  /* 194 */
	0,  /* 195 */
	0,  /* 196 */
	"NEGI",  /* 197 */
	0,  /* 198 */
	0,  /* 199 */
	0,  /* 200 */
	0,  /* 201 */
	0,  /* 202 */
	0,  /* 203 */
	0,  /* 204 */
	0,  /* 205 */
	0,  /* 206 */
	0,  /* 207 */
	0,  /* 208 */
	"CALLF",  /* 209 */
	"CALLD",  /* 210 */
	0,  /* 211 */
	0,  /* 212 */
	"CALLI",  /* 213 */
	0,  /* 214 */
	0,  /* 215 */
	"CALLV",  /* 216 */
	"CALLB",  /* 217 */
	0,  /* 218 */
	0,  /* 219 */
	0,  /* 220 */
	0,  /* 221 */
	0,  /* 222 */
	0,  /* 223 */
	0,  /* 224 */
	"LOADF",  /* 225 */
	"LOADD",  /* 226 */
	"LOADC",  /* 227 */
	"LOADS",  /* 228 */
	"LOADI",  /* 229 */
	"LOADU",  /* 230 */
	"LOADP",  /* 231 */
	0,  /* 232 */
	"LOADB",  /* 233 */
	0,  /* 234 */
	0,  /* 235 */
	0,  /* 236 */
	0,  /* 237 */
	0,  /* 238 */
	0,  /* 239 */
	0,  /* 240 */
	"RETF",  /* 241 */
	"RETD",  /* 242 */
	0,  /* 243 */
	0,  /* 244 */
	"RETI",  /* 245 */
	0,  /* 246 */
	0,  /* 247 */
	"RETV",  /* 248 */
	0,  /* 249 */
	0,  /* 250 */
	0,  /* 251 */
	0,  /* 252 */
	0,  /* 253 */
	0,  /* 254 */
	0,  /* 255 */
	0,  /* 256 */
	0,  /* 257 */
	0,  /* 258 */
	0,  /* 259 */
	0,  /* 260 */
	0,  /* 261 */
	0,  /* 262 */
	"ADDRGP",  /* 263 */
	0,  /* 264 */
	0,  /* 265 */
	0,  /* 266 */
	0,  /* 267 */
	0,  /* 268 */
	0,  /* 269 */
	0,  /* 270 */
	0,  /* 271 */
	0,  /* 272 */
	0,  /* 273 */
	0,  /* 274 */
	0,  /* 275 */
	0,  /* 276 */
	0,  /* 277 */
	0,  /* 278 */
	"ADDRFP",  /* 279 */
	0,  /* 280 */
	0,  /* 281 */
	0,  /* 282 */
	0,  /* 283 */
	0,  /* 284 */
	0,  /* 285 */
	0,  /* 286 */
	0,  /* 287 */
	0,  /* 288 */
	0,  /* 289 */
	0,  /* 290 */
	0,  /* 291 */
	0,  /* 292 */
	0,  /* 293 */
	0,  /* 294 */
	"ADDRLP",  /* 295 */
	0,  /* 296 */
	0,  /* 297 */
	0,  /* 298 */
	0,  /* 299 */
	0,  /* 300 */
	0,  /* 301 */
	0,  /* 302 */
	0,  /* 303 */
	0,  /* 304 */
	"ADDF",  /* 305 */
	"ADDD",  /* 306 */
	0,  /* 307 */
	0,  /* 308 */
	"ADDI",  /* 309 */
	"ADDU",  /* 310 */
	"ADDP",  /* 311 */
	0,  /* 312 */
	0,  /* 313 */
	0,  /* 314 */
	0,  /* 315 */
	0,  /* 316 */
	0,  /* 317 */
	0,  /* 318 */
	0,  /* 319 */
	0,  /* 320 */
	"SUBF",  /* 321 */
	"SUBD",  /* 322 */
	0,  /* 323 */
	0,  /* 324 */
	"SUBI",  /* 325 */
	"SUBU",  /* 326 */
	"SUBP",  /* 327 */
	0,  /* 328 */
	0,  /* 329 */
	0,  /* 330 */
	0,  /* 331 */
	0,  /* 332 */
	0,  /* 333 */
	0,  /* 334 */
	0,  /* 335 */
	0,  /* 336 */
	0,  /* 337 */
	0,  /* 338 */
	0,  /* 339 */
	0,  /* 340 */
	"LSHI",  /* 341 */
	"LSHU",  /* 342 */
	0,  /* 343 */
	0,  /* 344 */
	0,  /* 345 */
	0,  /* 346 */
	0,  /* 347 */
	0,  /* 348 */
	0,  /* 349 */
	0,  /* 350 */
	0,  /* 351 */
	0,  /* 352 */
	0,  /* 353 */
	0,  /* 354 */
	0,  /* 355 */
	0,  /* 356 */
	"MODI",  /* 357 */
	"MODU",  /* 358 */
	0,  /* 359 */
	0,  /* 360 */
	0,  /* 361 */
	0,  /* 362 */
	0,  /* 363 */
	0,  /* 364 */
	0,  /* 365 */
	0,  /* 366 */
	0,  /* 367 */
	0,  /* 368 */
	0,  /* 369 */
	0,  /* 370 */
	0,  /* 371 */
	0,  /* 372 */
	"RSHI",  /* 373 */
	"RSHU",  /* 374 */
	0,  /* 375 */
	0,  /* 376 */
	0,  /* 377 */
	0,  /* 378 */
	0,  /* 379 */
	0,  /* 380 */
	0,  /* 381 */
	0,  /* 382 */
	0,  /* 383 */
	0,  /* 384 */
	0,  /* 385 */
	0,  /* 386 */
	0,  /* 387 */
	0,  /* 388 */
	0,  /* 389 */
	"BANDU",  /* 390 */
	0,  /* 391 */
	0,  /* 392 */
	0,  /* 393 */
	0,  /* 394 */
	0,  /* 395 */
	0,  /* 396 */
	0,  /* 397 */
	0,  /* 398 */
	0,  /* 399 */
	0,  /* 400 */
	0,  /* 401 */
	0,  /* 402 */
	0,  /* 403 */
	0,  /* 404 */
	0,  /* 405 */
	"BCOMU",  /* 406 */
	0,  /* 407 */
	0,  /* 408 */
	0,  /* 409 */
	0,  /* 410 */
	0,  /* 411 */
	0,  /* 412 */
	0,  /* 413 */
	0,  /* 414 */
	0,  /* 415 */
	0,  /* 416 */
	0,  /* 417 */
	0,  /* 418 */
	0,  /* 419 */
	0,  /* 420 */
	0,  /* 421 */
	"BORU",  /* 422 */
	0,  /* 423 */
	0,  /* 424 */
	0,  /* 425 */
	0,  /* 426 */
	0,  /* 427 */
	0,  /* 428 */
	0,  /* 429 */
	0,  /* 430 */
	0,  /* 431 */
	0,  /* 432 */
	0,  /* 433 */
	0,  /* 434 */
	0,  /* 435 */
	0,  /* 436 */
	0,  /* 437 */
	"BXORU",  /* 438 */
	0,  /* 439 */
	0,  /* 440 */
	0,  /* 441 */
	0,  /* 442 */
	0,  /* 443 */
	0,  /* 444 */
	0,  /* 445 */
	0,  /* 446 */
	0,  /* 447 */
	0,  /* 448 */
	"DIVF",  /* 449 */
	"DIVD",  /* 450 */
	0,  /* 451 */
	0,  /* 452 */
	"DIVI",  /* 453 */
	"DIVU",  /* 454 */
	0,  /* 455 */
	0,  /* 456 */
	0,  /* 457 */
	0,  /* 458 */
	0,  /* 459 */
	0,  /* 460 */
	0,  /* 461 */
	0,  /* 462 */
	0,  /* 463 */
	0,  /* 464 */
	"MULF",  /* 465 */
	"MULD",  /* 466 */
	0,  /* 467 */
	0,  /* 468 */
	"MULI",  /* 469 */
	"MULU",  /* 470 */
	0,  /* 471 */
	0,  /* 472 */
	0,  /* 473 */
	0,  /* 474 */
	0,  /* 475 */
	0,  /* 476 */
	0,  /* 477 */
	0,  /* 478 */
	0,  /* 479 */
	0,  /* 480 */
	"EQF",  /* 481 */
	"EQD",  /* 482 */
	0,  /* 483 */
	0,  /* 484 */
	"EQI",  /* 485 */
	0,  /* 486 */
	0,  /* 487 */
	0,  /* 488 */
	0,  /* 489 */
	0,  /* 490 */
	0,  /* 491 */
	0,  /* 492 */
	0,  /* 493 */
	0,  /* 494 */
	0,  /* 495 */
	0,  /* 496 */
	"GEF",  /* 497 */
	"GED",  /* 498 */
	0,  /* 499 */
	0,  /* 500 */
	"GEI",  /* 501 */
	"GEU",  /* 502 */
	0,  /* 503 */
	0,  /* 504 */
	0,  /* 505 */
	0,  /* 506 */
	0,  /* 507 */
	0,  /* 508 */
	0,  /* 509 */
	0,  /* 510 */
	0,  /* 511 */
	0,  /* 512 */
	"GTF",  /* 513 */
	"GTD",  /* 514 */
	0,  /* 515 */
	0,  /* 516 */
	"GTI",  /* 517 */
	"GTU",  /* 518 */
	0,  /* 519 */
	0,  /* 520 */
	0,  /* 521 */
	0,  /* 522 */
	0,  /* 523 */
	0,  /* 524 */
	0,  /* 525 */
	0,  /* 526 */
	0,  /* 527 */
	0,  /* 528 */
	"LEF",  /* 529 */
	"LED",  /* 530 */
	0,  /* 531 */
	0,  /* 532 */
	"LEI",  /* 533 */
	"LEU",  /* 534 */
	0,  /* 535 */
	0,  /* 536 */
	0,  /* 537 */
	0,  /* 538 */
	0,  /* 539 */
	0,  /* 540 */
	0,  /* 541 */
	0,  /* 542 */
	0,  /* 543 */
	0,  /* 544 */
	"LTF",  /* 545 */
	"LTD",  /* 546 */
	0,  /* 547 */
	0,  /* 548 */
	"LTI",  /* 549 */
	"LTU",  /* 550 */
	0,  /* 551 */
	0,  /* 552 */
	0,  /* 553 */
	0,  /* 554 */
	0,  /* 555 */
	0,  /* 556 */
	0,  /* 557 */
	0,  /* 558 */
	0,  /* 559 */
	0,  /* 560 */
	"NEF",  /* 561 */
	"NED",  /* 562 */
	0,  /* 563 */
	0,  /* 564 */
	"NEI",  /* 565 */
	0,  /* 566 */
	0,  /* 567 */
	0,  /* 568 */
	0,  /* 569 */
	0,  /* 570 */
	0,  /* 571 */
	0,  /* 572 */
	0,  /* 573 */
	0,  /* 574 */
	0,  /* 575 */
	0,  /* 576 */
	0,  /* 577 */
	0,  /* 578 */
	0,  /* 579 */
	0,  /* 580 */
	0,  /* 581 */
	0,  /* 582 */
	0,  /* 583 */
	"JUMPV",  /* 584 */
	0,  /* 585 */
	0,  /* 586 */
	0,  /* 587 */
	0,  /* 588 */
	0,  /* 589 */
	0,  /* 590 */
	0,  /* 591 */
	0,  /* 592 */
	0,  /* 593 */
	0,  /* 594 */
	0,  /* 595 */
	0,  /* 596 */
	0,  /* 597 */
	0,  /* 598 */
	0,  /* 599 */
	"LABELV",  /* 600 */
	0,  /* 601 */
	0,  /* 602 */
	0,  /* 603 */
	0,  /* 604 */
	0,  /* 605 */
	0,  /* 606 */
	0,  /* 607 */
	0,  /* 608 */
	0,  /* 609 */
	0,  /* 610 */
	0,  /* 611 */
	0,  /* 612 */
	0,  /* 613 */
	0,  /* 614 */
	"VREGP",  /* 615 */
	0,  /* 616 */
	0,  /* 617 */
	0,  /* 618 */
	0,  /* 619 */
	0,  /* 620 */
	0,  /* 621 */
	0,  /* 622 */
	0,  /* 623 */
	0,  /* 624 */
	0,  /* 625 */
	0,  /* 626 */
	0,  /* 627 */
	0,  /* 628 */
	0,  /* 629 */
	0,  /* 630 */
	0,  /* 631 */
	0,  /* 632 */
	0,  /* 633 */
	0,  /* 634 */
	0,  /* 635 */
	0,  /* 636 */
	0,  /* 637 */
	0,  /* 638 */
	0,  /* 639 */
	0,  /* 640 */
	0,  /* 641 */
	0,  /* 642 */
	0,  /* 643 */
	0,  /* 644 */
	0,  /* 645 */
	0,  /* 646 */
	0,  /* 647 */
	0,  /* 648 */
	0,  /* 649 */
	0,  /* 650 */
	0,  /* 651 */
	0,  /* 652 */
	0,  /* 653 */
	0,  /* 654 */
	0,  /* 655 */
	0,  /* 656 */
	0,  /* 657 */
	0,  /* 658 */
	0,  /* 659 */
	0,  /* 660 */
	"I0I",  /* 661 */
	0,  /* 662 */
	0,  /* 663 */
	0,  /* 664 */
	0,  /* 665 */
	0,  /* 666 */
	0,  /* 667 */
	0,  /* 668 */
	0,  /* 669 */
	0,  /* 670 */
	0,  /* 671 */
	0,  /* 672 */
	0,  /* 673 */
	0,  /* 674 */
	0,  /* 675 */
	0,  /* 676 */
	"I1I",  /* 677 */
	0,  /* 678 */
	0,  /* 679 */
	0,  /* 680 */
	0,  /* 681 */
	0,  /* 682 */
	0,  /* 683 */
	0,  /* 684 */
	0,  /* 685 */
	0,  /* 686 */
	0,  /* 687 */
	0,  /* 688 */
	0,  /* 689 */
	0,  /* 690 */
	0,  /* 691 */
	0,  /* 692 */
	"I2I",  /* 693 */
	0,  /* 694 */
	0,  /* 695 */
	0,  /* 696 */
	0,  /* 697 */
	0,  /* 698 */
	0,  /* 699 */
	0,  /* 700 */
	0,  /* 701 */
	0,  /* 702 */
	0,  /* 703 */
	0,  /* 704 */
	0,  /* 705 */
	0,  /* 706 */
	0,  /* 707 */
	0,  /* 708 */
	"I3I",  /* 709 */
};

short sparc_cost[][4] = {
	{ 0 },
	{ 0 },  /* 1 = acon: ADDRGP */
	{ 0 },  /* 2 = acon: con */
	{ 0 },  /* 3 = addr: ADDRFP */
	{ 0 },  /* 4 = addr: ADDRLP */
	{ 0 },  /* 5 = addr: acon */
	{ 0 },  /* 6 = addr: reg */
	{ 0 },  /* 7 = ar: acon */
	{ 0 },  /* 8 = ar: reg */
	{ 0 },  /* 9 = rc: con */
	{ 0 },  /* 10 = rc: reg */
	{ 1 },  /* 11 = reg: ADDRGP */
	{ 1 },  /* 12 = reg: BCOMU(reg) */
	{ 1 },  /* 13 = reg: BXORU(reg,BCOMU(rc)) */
	{ 1 },  /* 14 = reg: BXORU(reg,rc) */
	{ 2 },  /* 15 = reg: CALLD(ar) */
	{ 2 },  /* 16 = reg: CALLF(ar) */
	{ 2 },  /* 17 = reg: CALLI(ar) */
	{ 1 },  /* 18 = reg: CVCI(INDIRC(addr)) */
	{ 1 },  /* 19 = reg: CVCI(reg) */
	{ 1 },  /* 20 = reg: CVCU(INDIRC(addr)) */
	{ 1 },  /* 21 = reg: CVCU(reg) */
	{ 1 },  /* 22 = reg: CVDF(reg) */
	{ 1 },  /* 23 = reg: CVDI(reg) */
	{ 1 },  /* 24 = reg: CVFD(reg) */
	{ 1 },  /* 25 = reg: CVID(reg) */
	{ 1 },  /* 26 = reg: CVSI(INDIRS(addr)) */
	{ 1 },  /* 27 = reg: CVSI(reg) */
	{ 1 },  /* 28 = reg: CVSU(INDIRS(addr)) */
	{ 1 },  /* 29 = reg: CVSU(reg) */
	{ 1 },  /* 30 = reg: LOADD(reg) */
	{ 1 },  /* 31 = reg: LOADF(reg) */
	{ 1 },  /* 32 = reg: NEGD(reg) */
	{ 1 },  /* 33 = reg: NEGF(reg) */
	{ 1 },  /* 34 = reg: NEGI(reg) */
	{ 1 },  /* 35 = reg: con */
	{ 1 },  /* 36 = stmt: ARGD(reg) */
	{ 1 },  /* 37 = stmt: ARGF(reg) */
	{ 0 },  /* 38 = stmt: ASGNB(reg,reg) */
	{ 2 },  /* 39 = stmt: CALLB(ar,reg) */
	{ 2 },  /* 40 = stmt: CALLV(ar) */
	{ 1 },  /* 41 = stmt: JUMPV(acon) */
	{ 1 },  /* 42 = stmt: JUMPV(addr) */
	{ 0 },  /* 43 = stmt: LABELV */
	{ 1 },  /* 44 = stmt: RETV */
	{ 0 },  /* 45 = stmt: reg */
	{ 0 },  /* 46 = addr: ADDI(reg,rc) */
	{ 0 },  /* 47 = addr: ADDP(reg,rc) */
	{ 0 },  /* 48 = addr: ADDU(reg,rc) */
	{ 0 },  /* 49 = con: CNSTI */
	{ 0 },  /* 50 = con: CNSTP */
	{ 0 },  /* 51 = con: CNSTU */
	{ 0 },  /* 52 = con: CNSTC */
	{ 0 },  /* 53 = con: CNSTS */
	{ 0 },  /* 54 = con: I0I */
	{ 0 },  /* 55 = con: I1I */
	{ 0 },  /* 56 = con: I2I */
	{ 0 },  /* 57 = con: I3I */
	{ 1 },  /* 58 = reg: ADDF(reg,reg) */
	{ 1 },  /* 59 = reg: ADDD(reg,reg) */
	{ 1 },  /* 60 = reg: SUBF(reg,reg) */
	{ 1 },  /* 61 = reg: SUBD(reg,reg) */
	{ 1 },  /* 62 = reg: MULF(reg,reg) */
	{ 1 },  /* 63 = reg: MULD(reg,reg) */
	{ 1 },  /* 64 = reg: DIVF(reg,reg) */
	{ 1 },  /* 65 = reg: DIVD(reg,reg) */
	{ 1 },  /* 66 = reg: BANDU(reg,BCOMU(rc)) */
	{ 1 },  /* 67 = reg: BORU(reg,BCOMU(rc)) */
	{ 1 },  /* 68 = reg: BANDU(reg,rc) */
	{ 1 },  /* 69 = reg: BORU(reg,rc) */
	{ 1 },  /* 70 = reg: CVIC(reg) */
	{ 1 },  /* 71 = reg: CVIS(reg) */
	{ 1 },  /* 72 = reg: CVIU(reg) */
	{ 1 },  /* 73 = reg: CVUC(reg) */
	{ 1 },  /* 74 = reg: CVUS(reg) */
	{ 1 },  /* 75 = reg: CVUI(reg) */
	{ 1 },  /* 76 = reg: CVPU(reg) */
	{ 1 },  /* 77 = reg: CVUP(reg) */
	{ 1 },  /* 78 = reg: INDIRB(reg) */
	{ 1 },  /* 79 = reg: LOADC(reg) */
	{ 1 },  /* 80 = reg: LOADS(reg) */
	{ 1 },  /* 81 = reg: LOADI(reg) */
	{ 1 },  /* 82 = reg: LOADP(reg) */
	{ 1 },  /* 83 = reg: LOADU(reg) */
	{ 1 },  /* 84 = reg: LOADB(reg) */
	{ 1 },  /* 85 = reg: DIVI(reg,reg) */
	{ 1 },  /* 86 = reg: DIVU(reg,reg) */
	{ 1 },  /* 87 = reg: MODI(reg,reg) */
	{ 1 },  /* 88 = reg: MODU(reg,reg) */
	{ 1 },  /* 89 = reg: MULI(reg,reg) */
	{ 1 },  /* 90 = reg: MULU(reg,reg) */
	{ 0 },  /* 91 = reg: I0I */
	{ 1 },  /* 92 = reg: INDIRF(addr) */
	{ 1 },  /* 93 = reg: INDIRD(addr) */
	{ 1 },  /* 94 = reg: INDIRI(addr) */
	{ 1 },  /* 95 = reg: INDIRP(addr) */
	{ 1 },  /* 96 = reg: INDIRC(addr) */
	{ 1 },  /* 97 = reg: INDIRS(addr) */
	{ 0 },  /* 98 = reg: INDIRF(VREGP) */
	{ 0 },  /* 99 = reg: INDIRD(VREGP) */
	{ 0 },  /* 100 = reg: INDIRI(VREGP) */
	{ 0 },  /* 101 = reg: INDIRP(VREGP) */
	{ 0 },  /* 102 = reg: INDIRC(VREGP) */
	{ 0 },  /* 103 = reg: INDIRS(VREGP) */
	{ 1 },  /* 104 = stmt: EQI(reg,rc) */
	{ 1 },  /* 105 = stmt: NEI(reg,rc) */
	{ 1 },  /* 106 = stmt: GTI(reg,rc) */
	{ 1 },  /* 107 = stmt: GEI(reg,rc) */
	{ 1 },  /* 108 = stmt: LTI(reg,rc) */
	{ 1 },  /* 109 = stmt: LEI(reg,rc) */
	{ 1 },  /* 110 = stmt: GTU(reg,rc) */
	{ 1 },  /* 111 = stmt: GEU(reg,rc) */
	{ 1 },  /* 112 = stmt: LTU(reg,rc) */
	{ 1 },  /* 113 = stmt: LEU(reg,rc) */
	{ 1 },  /* 114 = stmt: ARGI(reg) */
	{ 1 },  /* 115 = stmt: ARGP(reg) */
	{ 1 },  /* 116 = stmt: ASGNF(addr,reg) */
	{ 1 },  /* 117 = stmt: ASGND(addr,reg) */
	{ 1 },  /* 118 = stmt: ASGNI(addr,reg) */
	{ 1 },  /* 119 = stmt: ASGNP(addr,reg) */
	{ 1 },  /* 120 = stmt: ASGNC(addr,reg) */
	{ 1 },  /* 121 = stmt: ASGNS(addr,reg) */
	{ 0 },  /* 122 = stmt: ASGNF(VREGP,reg) */
	{ 0 },  /* 123 = stmt: ASGND(VREGP,reg) */
	{ 0 },  /* 124 = stmt: ASGNI(VREGP,reg) */
	{ 0 },  /* 125 = stmt: ASGNP(VREGP,reg) */
	{ 0 },  /* 126 = stmt: ASGNC(VREGP,reg) */
	{ 0 },  /* 127 = stmt: ASGNS(VREGP,reg) */
	{ 1 },  /* 128 = stmt: RETF(reg) */
	{ 1 },  /* 129 = stmt: RETD(reg) */
	{ 1 },  /* 130 = stmt: RETI(reg) */
	{ 1 },  /* 131 = reg: ADDI(reg,rc) */
	{ 1 },  /* 132 = reg: ADDP(reg,rc) */
	{ 1 },  /* 133 = reg: ADDU(reg,rc) */
	{ 1 },  /* 134 = reg: SUBI(reg,rc) */
	{ 1 },  /* 135 = reg: SUBP(reg,rc) */
	{ 1 },  /* 136 = reg: SUBU(reg,rc) */
	{ 1 },  /* 137 = reg: LSHI(reg,rc) */
	{ 1 },  /* 138 = reg: LSHU(reg,rc) */
	{ 1 },  /* 139 = reg: RSHU(reg,rc) */
	{ 1 },  /* 140 = reg: RSHI(reg,rc) */
};

char *sparc_string[] = {
	0,
	"acon: ADDRGP",  /* 1 */
	"acon: con",  /* 2 */
	"addr: ADDRFP",  /* 3 */
	"addr: ADDRLP",  /* 4 */
	"addr: acon",  /* 5 */
	"addr: reg",  /* 6 */
	"ar: acon",  /* 7 */
	"ar: reg",  /* 8 */
	"rc: con",  /* 9 */
	"rc: reg",  /* 10 */
	"reg: ADDRGP",  /* 11 */
	"reg: BCOMU(reg)",  /* 12 */
	"reg: BXORU(reg,BCOMU(rc))",  /* 13 */
	"reg: BXORU(reg,rc)",  /* 14 */
	"reg: CALLD(ar)",  /* 15 */
	"reg: CALLF(ar)",  /* 16 */
	"reg: CALLI(ar)",  /* 17 */
	"reg: CVCI(INDIRC(addr))",  /* 18 */
	"reg: CVCI(reg)",  /* 19 */
	"reg: CVCU(INDIRC(addr))",  /* 20 */
	"reg: CVCU(reg)",  /* 21 */
	"reg: CVDF(reg)",  /* 22 */
	"reg: CVDI(reg)",  /* 23 */
	"reg: CVFD(reg)",  /* 24 */
	"reg: CVID(reg)",  /* 25 */
	"reg: CVSI(INDIRS(addr))",  /* 26 */
	"reg: CVSI(reg)",  /* 27 */
	"reg: CVSU(INDIRS(addr))",  /* 28 */
	"reg: CVSU(reg)",  /* 29 */
	"reg: LOADD(reg)",  /* 30 */
	"reg: LOADF(reg)",  /* 31 */
	"reg: NEGD(reg)",  /* 32 */
	"reg: NEGF(reg)",  /* 33 */
	"reg: NEGI(reg)",  /* 34 */
	"reg: con",  /* 35 */
	"stmt: ARGD(reg)",  /* 36 */
	"stmt: ARGF(reg)",  /* 37 */
	"stmt: ASGNB(reg,reg)",  /* 38 */
	"stmt: CALLB(ar,reg)",  /* 39 */
	"stmt: CALLV(ar)",  /* 40 */
	"stmt: JUMPV(acon)",  /* 41 */
	"stmt: JUMPV(addr)",  /* 42 */
	"stmt: LABELV",  /* 43 */
	"stmt: RETV",  /* 44 */
	"stmt: reg",  /* 45 */
	"addr: ADDI(reg,rc)",  /* 46 */
	"addr: ADDP(reg,rc)",  /* 47 */
	"addr: ADDU(reg,rc)",  /* 48 */
	"con: CNSTI",  /* 49 */
	"con: CNSTP",  /* 50 */
	"con: CNSTU",  /* 51 */
	"con: CNSTC",  /* 52 */
	"con: CNSTS",  /* 53 */
	"con: I0I",  /* 54 */
	"con: I1I",  /* 55 */
	"con: I2I",  /* 56 */
	"con: I3I",  /* 57 */
	"reg: ADDF(reg,reg)",  /* 58 */
	"reg: ADDD(reg,reg)",  /* 59 */
	"reg: SUBF(reg,reg)",  /* 60 */
	"reg: SUBD(reg,reg)",  /* 61 */
	"reg: MULF(reg,reg)",  /* 62 */
	"reg: MULD(reg,reg)",  /* 63 */
	"reg: DIVF(reg,reg)",  /* 64 */
	"reg: DIVD(reg,reg)",  /* 65 */
	"reg: BANDU(reg,BCOMU(rc))",  /* 66 */
	"reg: BORU(reg,BCOMU(rc))",  /* 67 */
	"reg: BANDU(reg,rc)",  /* 68 */
	"reg: BORU(reg,rc)",  /* 69 */
	"reg: CVIC(reg)",  /* 70 */
	"reg: CVIS(reg)",  /* 71 */
	"reg: CVIU(reg)",  /* 72 */
	"reg: CVUC(reg)",  /* 73 */
	"reg: CVUS(reg)",  /* 74 */
	"reg: CVUI(reg)",  /* 75 */
	"reg: CVPU(reg)",  /* 76 */
	"reg: CVUP(reg)",  /* 77 */
	"reg: INDIRB(reg)",  /* 78 */
	"reg: LOADC(reg)",  /* 79 */
	"reg: LOADS(reg)",  /* 80 */
	"reg: LOADI(reg)",  /* 81 */
	"reg: LOADP(reg)",  /* 82 */
	"reg: LOADU(reg)",  /* 83 */
	"reg: LOADB(reg)",  /* 84 */
	"reg: DIVI(reg,reg)",  /* 85 */
	"reg: DIVU(reg,reg)",  /* 86 */
	"reg: MODI(reg,reg)",  /* 87 */
	"reg: MODU(reg,reg)",  /* 88 */
	"reg: MULI(reg,reg)",  /* 89 */
	"reg: MULU(reg,reg)",  /* 90 */
	"reg: I0I",  /* 91 */
	"reg: INDIRF(addr)",  /* 92 */
	"reg: INDIRD(addr)",  /* 93 */
	"reg: INDIRI(addr)",  /* 94 */
	"reg: INDIRP(addr)",  /* 95 */
	"reg: INDIRC(addr)",  /* 96 */
	"reg: INDIRS(addr)",  /* 97 */
	"reg: INDIRF(VREGP)",  /* 98 */
	"reg: INDIRD(VREGP)",  /* 99 */
	"reg: INDIRI(VREGP)",  /* 100 */
	"reg: INDIRP(VREGP)",  /* 101 */
	"reg: INDIRC(VREGP)",  /* 102 */
	"reg: INDIRS(VREGP)",  /* 103 */
	"stmt: EQI(reg,rc)",  /* 104 */
	"stmt: NEI(reg,rc)",  /* 105 */
	"stmt: GTI(reg,rc)",  /* 106 */
	"stmt: GEI(reg,rc)",  /* 107 */
	"stmt: LTI(reg,rc)",  /* 108 */
	"stmt: LEI(reg,rc)",  /* 109 */
	"stmt: GTU(reg,rc)",  /* 110 */
	"stmt: GEU(reg,rc)",  /* 111 */
	"stmt: LTU(reg,rc)",  /* 112 */
	"stmt: LEU(reg,rc)",  /* 113 */
	"stmt: ARGI(reg)",  /* 114 */
	"stmt: ARGP(reg)",  /* 115 */
	"stmt: ASGNF(addr,reg)",  /* 116 */
	"stmt: ASGND(addr,reg)",  /* 117 */
	"stmt: ASGNI(addr,reg)",  /* 118 */
	"stmt: ASGNP(addr,reg)",  /* 119 */
	"stmt: ASGNC(addr,reg)",  /* 120 */
	"stmt: ASGNS(addr,reg)",  /* 121 */
	"stmt: ASGNF(VREGP,reg)",  /* 122 */
	"stmt: ASGND(VREGP,reg)",  /* 123 */
	"stmt: ASGNI(VREGP,reg)",  /* 124 */
	"stmt: ASGNP(VREGP,reg)",  /* 125 */
	"stmt: ASGNC(VREGP,reg)",  /* 126 */
	"stmt: ASGNS(VREGP,reg)",  /* 127 */
	"stmt: RETF(reg)",  /* 128 */
	"stmt: RETD(reg)",  /* 129 */
	"stmt: RETI(reg)",  /* 130 */
	"reg: ADDI(reg,rc)",  /* 131 */
	"reg: ADDP(reg,rc)",  /* 132 */
	"reg: ADDU(reg,rc)",  /* 133 */
	"reg: SUBI(reg,rc)",  /* 134 */
	"reg: SUBP(reg,rc)",  /* 135 */
	"reg: SUBU(reg,rc)",  /* 136 */
	"reg: LSHI(reg,rc)",  /* 137 */
	"reg: LSHU(reg,rc)",  /* 138 */
	"reg: RSHU(reg,rc)",  /* 139 */
	"reg: RSHI(reg,rc)",  /* 140 */
};

static short sparc_nts_1[] = { 0 };
static short sparc_nts_2[] = { sparc_con_NT, 0 };
static short sparc_nts_5[] = { sparc_acon_NT, 0 };
static short sparc_nts_6[] = { sparc_reg_NT, 0 };
static short sparc_nts_13[] = { sparc_reg_NT, sparc_rc_NT, 0 };
static short sparc_nts_15[] = { sparc_ar_NT, 0 };
static short sparc_nts_18[] = { sparc_addr_NT, 0 };
static short sparc_nts_38[] = { sparc_reg_NT, sparc_reg_NT, 0 };
static short sparc_nts_39[] = { sparc_ar_NT, sparc_reg_NT, 0 };
static short sparc_nts_116[] = { sparc_addr_NT, sparc_reg_NT, 0 };

short *sparc_nts[] = {
	0,
	sparc_nts_1,	/* 1 */
	sparc_nts_2,	/* 2 */
	sparc_nts_1,	/* 3 */
	sparc_nts_1,	/* 4 */
	sparc_nts_5,	/* 5 */
	sparc_nts_6,	/* 6 */
	sparc_nts_5,	/* 7 */
	sparc_nts_6,	/* 8 */
	sparc_nts_2,	/* 9 */
	sparc_nts_6,	/* 10 */
	sparc_nts_1,	/* 11 */
	sparc_nts_6,	/* 12 */
	sparc_nts_13,	/* 13 */
	sparc_nts_13,	/* 14 */
	sparc_nts_15,	/* 15 */
	sparc_nts_15,	/* 16 */
	sparc_nts_15,	/* 17 */
	sparc_nts_18,	/* 18 */
	sparc_nts_6,	/* 19 */
	sparc_nts_18,	/* 20 */
	sparc_nts_6,	/* 21 */
	sparc_nts_6,	/* 22 */
	sparc_nts_6,	/* 23 */
	sparc_nts_6,	/* 24 */
	sparc_nts_6,	/* 25 */
	sparc_nts_18,	/* 26 */
	sparc_nts_6,	/* 27 */
	sparc_nts_18,	/* 28 */
	sparc_nts_6,	/* 29 */
	sparc_nts_6,	/* 30 */
	sparc_nts_6,	/* 31 */
	sparc_nts_6,	/* 32 */
	sparc_nts_6,	/* 33 */
	sparc_nts_6,	/* 34 */
	sparc_nts_2,	/* 35 */
	sparc_nts_6,	/* 36 */
	sparc_nts_6,	/* 37 */
	sparc_nts_38,	/* 38 */
	sparc_nts_39,	/* 39 */
	sparc_nts_15,	/* 40 */
	sparc_nts_5,	/* 41 */
	sparc_nts_18,	/* 42 */
	sparc_nts_1,	/* 43 */
	sparc_nts_1,	/* 44 */
	sparc_nts_6,	/* 45 */
	sparc_nts_13,	/* 46 */
	sparc_nts_13,	/* 47 */
	sparc_nts_13,	/* 48 */
	sparc_nts_1,	/* 49 */
	sparc_nts_1,	/* 50 */
	sparc_nts_1,	/* 51 */
	sparc_nts_1,	/* 52 */
	sparc_nts_1,	/* 53 */
	sparc_nts_1,	/* 54 */
	sparc_nts_1,	/* 55 */
	sparc_nts_1,	/* 56 */
	sparc_nts_1,	/* 57 */
	sparc_nts_38,	/* 58 */
	sparc_nts_38,	/* 59 */
	sparc_nts_38,	/* 60 */
	sparc_nts_38,	/* 61 */
	sparc_nts_38,	/* 62 */
	sparc_nts_38,	/* 63 */
	sparc_nts_38,	/* 64 */
	sparc_nts_38,	/* 65 */
	sparc_nts_13,	/* 66 */
	sparc_nts_13,	/* 67 */
	sparc_nts_13,	/* 68 */
	sparc_nts_13,	/* 69 */
	sparc_nts_6,	/* 70 */
	sparc_nts_6,	/* 71 */
	sparc_nts_6,	/* 72 */
	sparc_nts_6,	/* 73 */
	sparc_nts_6,	/* 74 */
	sparc_nts_6,	/* 75 */
	sparc_nts_6,	/* 76 */
	sparc_nts_6,	/* 77 */
	sparc_nts_6,	/* 78 */
	sparc_nts_6,	/* 79 */
	sparc_nts_6,	/* 80 */
	sparc_nts_6,	/* 81 */
	sparc_nts_6,	/* 82 */
	sparc_nts_6,	/* 83 */
	sparc_nts_6,	/* 84 */
	sparc_nts_38,	/* 85 */
	sparc_nts_38,	/* 86 */
	sparc_nts_38,	/* 87 */
	sparc_nts_38,	/* 88 */
	sparc_nts_38,	/* 89 */
	sparc_nts_38,	/* 90 */
	sparc_nts_1,	/* 91 */
	sparc_nts_18,	/* 92 */
	sparc_nts_18,	/* 93 */
	sparc_nts_18,	/* 94 */
	sparc_nts_18,	/* 95 */
	sparc_nts_18,	/* 96 */
	sparc_nts_18,	/* 97 */
	sparc_nts_1,	/* 98 */
	sparc_nts_1,	/* 99 */
	sparc_nts_1,	/* 100 */
	sparc_nts_1,	/* 101 */
	sparc_nts_1,	/* 102 */
	sparc_nts_1,	/* 103 */
	sparc_nts_13,	/* 104 */
	sparc_nts_13,	/* 105 */
	sparc_nts_13,	/* 106 */
	sparc_nts_13,	/* 107 */
	sparc_nts_13,	/* 108 */
	sparc_nts_13,	/* 109 */
	sparc_nts_13,	/* 110 */
	sparc_nts_13,	/* 111 */
	sparc_nts_13,	/* 112 */
	sparc_nts_13,	/* 113 */
	sparc_nts_6,	/* 114 */
	sparc_nts_6,	/* 115 */
	sparc_nts_116,	/* 116 */
	sparc_nts_116,	/* 117 */
	sparc_nts_116,	/* 118 */
	sparc_nts_116,	/* 119 */
	sparc_nts_116,	/* 120 */
	sparc_nts_116,	/* 121 */
	sparc_nts_6,	/* 122 */
	sparc_nts_6,	/* 123 */
	sparc_nts_6,	/* 124 */
	sparc_nts_6,	/* 125 */
	sparc_nts_6,	/* 126 */
	sparc_nts_6,	/* 127 */
	sparc_nts_6,	/* 128 */
	sparc_nts_6,	/* 129 */
	sparc_nts_6,	/* 130 */
	sparc_nts_13,	/* 131 */
	sparc_nts_13,	/* 132 */
	sparc_nts_13,	/* 133 */
	sparc_nts_13,	/* 134 */
	sparc_nts_13,	/* 135 */
	sparc_nts_13,	/* 136 */
	sparc_nts_13,	/* 137 */
	sparc_nts_13,	/* 138 */
	sparc_nts_13,	/* 139 */
	sparc_nts_13,	/* 140 */
};

struct sparc_state {
	int op;
	struct sparc_state *left, *right;
	short cost[8];
	struct {
		unsigned int sparc_stmt:6;
		unsigned int sparc_acon:2;
		unsigned int sparc_addr:3;
		unsigned int sparc_ar:2;
		unsigned int sparc_con:4;
		unsigned int sparc_rc:2;
		unsigned int sparc_reg:7;
	} rule;
};

static short sparc_decode_acon[] = {
	0,
	1,
	2,
};

static short sparc_decode_rc[] = {
	0,
	9,
	10,
};

static short sparc_decode_stmt[] = {
	0,
	36,
	37,
	38,
	39,
	40,
	41,
	42,
	43,
	44,
	45,
	104,
	105,
	106,
	107,
	108,
	109,
	110,
	111,
	112,
	113,
	114,
	115,
	116,
	117,
	118,
	119,
	120,
	121,
	122,
	123,
	124,
	125,
	126,
	127,
	128,
	129,
	130,
};

static short sparc_decode_ar[] = {
	0,
	7,
	8,
};

static short sparc_decode_reg[] = {
	0,
	11,
	12,
	13,
	14,
	15,
	16,
	17,
	18,
	19,
	20,
	21,
	22,
	23,
	24,
	25,
	26,
	27,
	28,
	29,
	30,
	31,
	32,
	33,
	34,
	35,
	58,
	59,
	60,
	61,
	62,
	63,
	64,
	65,
	66,
	67,
	68,
	69,
	70,
	71,
	72,
	73,
	74,
	75,
	76,
	77,
	78,
	79,
	80,
	81,
	82,
	83,
	84,
	85,
	86,
	87,
	88,
	89,
	90,
	91,
	92,
	93,
	94,
	95,
	96,
	97,
	98,
	99,
	100,
	101,
	102,
	103,
	131,
	132,
	133,
	134,
	135,
	136,
	137,
	138,
	139,
	140,
};

static short sparc_decode_con[] = {
	0,
	49,
	50,
	51,
	52,
	53,
	54,
	55,
	56,
	57,
};

static short sparc_decode_addr[] = {
	0,
	3,
	4,
	5,
	6,
	46,
	47,
	48,
};

#ifdef __STDC__
int sparc_rule(int, int);
int sparc_state(int, int, int);
#else
int sparc_rule();
int sparc_state();
#endif

#define sparc_acon_rule(a)	sparc_decode_acon[((struct sparc_state *)a)->rule.sparc_acon];
#define sparc_rc_rule(a)	sparc_decode_rc[((struct sparc_state *)a)->rule.sparc_rc];
#define sparc_stmt_rule(a)	sparc_decode_stmt[((struct sparc_state *)a)->rule.sparc_stmt];
#define sparc_ar_rule(a)	sparc_decode_ar[((struct sparc_state *)a)->rule.sparc_ar];
#define sparc_reg_rule(a)	sparc_decode_reg[((struct sparc_state *)a)->rule.sparc_reg];
#define sparc_con_rule(a)	sparc_decode_con[((struct sparc_state *)a)->rule.sparc_con];
#define sparc_addr_rule(a)	sparc_decode_addr[((struct sparc_state *)a)->rule.sparc_addr];
int sparc_rule(state, goalnt) {
	CHECK(goalnt >= 1 && goalnt <= 7, PANIC("Bad goal nonterminal %d in sparc_rule\n", goalnt))
	if (!state)
		return 0;
	switch (goalnt) {
	case sparc_acon_NT:	return sparc_acon_rule(state);
	case sparc_rc_NT:	return sparc_rc_rule(state);
	case sparc_stmt_NT:	return sparc_stmt_rule(state);
	case sparc_ar_NT:	return sparc_ar_rule(state);
	case sparc_reg_NT:	return sparc_reg_rule(state);
	case sparc_con_NT:	return sparc_con_rule(state);
	case sparc_addr_NT:	return sparc_addr_rule(state);
	default:
		PANIC("Bad goalnt in sparc_rule\n");
		return 0;
	}
}

#ifdef __STDC__
static void sparc_closure_acon(struct sparc_state *, int);
static void sparc_closure_reg(struct sparc_state *, int);
static void sparc_closure_con(struct sparc_state *, int);
#else
static void sparc_closure_acon();
static void sparc_closure_reg();
static void sparc_closure_con();
#endif

static void sparc_closure_acon(p, c) struct sparc_state *p; {
	if (c + 0 < p->cost[sparc_ar_NT]) {  /* ar : acon */
		p->cost[sparc_ar_NT] = c + 0;
		p->rule.sparc_ar = 1;
	}
	if (c + 0 < p->cost[sparc_addr_NT]) {  /* addr : acon */
		p->cost[sparc_addr_NT] = c + 0;
		p->rule.sparc_addr = 3;
	}
}

static void sparc_closure_reg(p, c) struct sparc_state *p; {
	if (c + 0 < p->cost[sparc_rc_NT]) {  /* rc : reg */
		p->cost[sparc_rc_NT] = c + 0;
		p->rule.sparc_rc = 2;
	}
	if (c + 0 < p->cost[sparc_stmt_NT]) {  /* stmt : reg */
		p->cost[sparc_stmt_NT] = c + 0;
		p->rule.sparc_stmt = 10;
	}
	if (c + 0 < p->cost[sparc_ar_NT]) {  /* ar : reg */
		p->cost[sparc_ar_NT] = c + 0;
		p->rule.sparc_ar = 2;
	}
	if (c + 0 < p->cost[sparc_addr_NT]) {  /* addr : reg */
		p->cost[sparc_addr_NT] = c + 0;
		p->rule.sparc_addr = 4;
	}
}

static void sparc_closure_con(p, c) struct sparc_state *p; {
	if (c + 0 < p->cost[sparc_acon_NT]) {  /* acon : con */
		p->cost[sparc_acon_NT] = c + 0;
		p->rule.sparc_acon = 2;
		sparc_closure_acon(p, c + 0);
	}
	if (c + 0 < p->cost[sparc_rc_NT]) {  /* rc : con */
		p->cost[sparc_rc_NT] = c + 0;
		p->rule.sparc_rc = 1;
	}
	if (c + 1 < p->cost[sparc_reg_NT]) {  /* reg : con */
		p->cost[sparc_reg_NT] = c + 1;
		p->rule.sparc_reg = 25;
		sparc_closure_reg(p, c + 1);
	}
}

int sparc_state(op, left, right) {
	int c;
	struct sparc_state *p, *l = (struct sparc_state *) left, *r = (struct sparc_state *) right;

	if (sparc_arity[op] > 0) {
		p = (void *)ALLOC(sizeof (struct sparc_state));
		CHECK(p, PANIC("ALLOC returned NULL in sparc_state\n"))
		p->op = op;
		p->left = l;
		p->right = r;
		p->rule.sparc_stmt = 0;
		p->cost[1] = 
		p->cost[2] = 
		p->cost[3] = 
		p->cost[4] = 
		p->cost[5] = 
		p->cost[6] = 
		p->cost[7] = 
			0x7fff;
	}
	switch (op) {
	case 306:  /* ADDD */
		assert(l && r);
		c = l->cost[sparc_reg_NT] + r->cost[sparc_reg_NT] + 1;
		if (c + 0 < p->cost[sparc_reg_NT]) {  /* reg : ADDD(reg,reg) */
			p->cost[sparc_reg_NT] = c + 0;
			p->rule.sparc_reg = 27;
			sparc_closure_reg(p, c + 0);
		}
		break;
	case 305:  /* ADDF */
		assert(l && r);
		c = l->cost[sparc_reg_NT] + r->cost[sparc_reg_NT] + 1;
		if (c + 0 < p->cost[sparc_reg_NT]) {  /* reg : ADDF(reg,reg) */
			p->cost[sparc_reg_NT] = c + 0;
			p->rule.sparc_reg = 26;
			sparc_closure_reg(p, c + 0);
		}
		break;
	case 309:  /* ADDI */
		assert(l && r);
		c = l->cost[sparc_reg_NT] + r->cost[sparc_rc_NT] + 0;
		if (c + 0 < p->cost[sparc_addr_NT]) {  /* addr : ADDI(reg,rc) */
			p->cost[sparc_addr_NT] = c + 0;
			p->rule.sparc_addr = 5;
		}
		c = l->cost[sparc_reg_NT] + r->cost[sparc_rc_NT] + 1;
		if (c + 0 < p->cost[sparc_reg_NT]) {  /* reg : ADDI(reg,rc) */
			p->cost[sparc_reg_NT] = c + 0;
			p->rule.sparc_reg = 72;
			sparc_closure_reg(p, c + 0);
		}
		break;
	case 311:  /* ADDP */
		assert(l && r);
		c = l->cost[sparc_reg_NT] + r->cost[sparc_rc_NT] + 0;
		if (c + 0 < p->cost[sparc_addr_NT]) {  /* addr : ADDP(reg,rc) */
			p->cost[sparc_addr_NT] = c + 0;
			p->rule.sparc_addr = 6;
		}
		c = l->cost[sparc_reg_NT] + r->cost[sparc_rc_NT] + 1;
		if (c + 0 < p->cost[sparc_reg_NT]) {  /* reg : ADDP(reg,rc) */
			p->cost[sparc_reg_NT] = c + 0;
			p->rule.sparc_reg = 73;
			sparc_closure_reg(p, c + 0);
		}
		break;
	case 279:  /* ADDRFP */
		{
			static struct sparc_state z = { 279, 0, 0,
				{	0,
					0x7fff,
					0x7fff,
					0,	/* addr: ADDRFP */
					0x7fff,
					0x7fff,
					0x7fff,
					0x7fff,
				},{
					0,
					0,
					1,	/* addr: ADDRFP */
					0,
					0,
					0,
					0,
				}
			};
			return (int)&z;
		}
	case 263:  /* ADDRGP */
		{
			static struct sparc_state z = { 263, 0, 0,
				{	0,
					0,	/* stmt: reg */
					0,	/* acon: ADDRGP */
					0,	/* addr: acon */
					0,	/* ar: acon */
					0x7fff,
					0,	/* rc: reg */
					1,	/* reg: ADDRGP */
				},{
					10,	/* stmt: reg */
					1,	/* acon: ADDRGP */
					3,	/* addr: acon */
					1,	/* ar: acon */
					0,
					2,	/* rc: reg */
					1,	/* reg: ADDRGP */
				}
			};
			return (int)&z;
		}
	case 295:  /* ADDRLP */
		{
			static struct sparc_state z = { 295, 0, 0,
				{	0,
					0x7fff,
					0x7fff,
					0,	/* addr: ADDRLP */
					0x7fff,
					0x7fff,
					0x7fff,
					0x7fff,
				},{
					0,
					0,
					2,	/* addr: ADDRLP */
					0,
					0,
					0,
					0,
				}
			};
			return (int)&z;
		}
	case 310:  /* ADDU */
		assert(l && r);
		c = l->cost[sparc_reg_NT] + r->cost[sparc_rc_NT] + 0;
		if (c + 0 < p->cost[sparc_addr_NT]) {  /* addr : ADDU(reg,rc) */
			p->cost[sparc_addr_NT] = c + 0;
			p->rule.sparc_addr = 7;
		}
		c = l->cost[sparc_reg_NT] + r->cost[sparc_rc_NT] + 1;
		if (c + 0 < p->cost[sparc_reg_NT]) {  /* reg : ADDU(reg,rc) */
			p->cost[sparc_reg_NT] = c + 0;
			p->rule.sparc_reg = 74;
			sparc_closure_reg(p, c + 0);
		}
		break;
	case 41:  /* ARGB */
		{
			static struct sparc_state z = { 41, 0, 0,
				{	0,
					0x7fff,
					0x7fff,
					0x7fff,
					0x7fff,
					0x7fff,
					0x7fff,
					0x7fff,
				},{
					0,
					0,
					0,
					0,
					0,
					0,
					0,
				}
			};
			return (int)&z;
		}
	case 34:  /* ARGD */
		assert(l);
		c = l->cost[sparc_reg_NT] + 1;
		if (c + 0 < p->cost[sparc_stmt_NT]) {  /* stmt : ARGD(reg) */
			p->cost[sparc_stmt_NT] = c + 0;
			p->rule.sparc_stmt = 1;
		}
		break;
	case 33:  /* ARGF */
		assert(l);
		c = l->cost[sparc_reg_NT] + 1;
		if (c + 0 < p->cost[sparc_stmt_NT]) {  /* stmt : ARGF(reg) */
			p->cost[sparc_stmt_NT] = c + 0;
			p->rule.sparc_stmt = 2;
		}
		break;
	case 37:  /* ARGI */
		assert(l);
		c = l->cost[sparc_reg_NT] + 1;
		if (c + 0 < p->cost[sparc_stmt_NT]) {  /* stmt : ARGI(reg) */
			p->cost[sparc_stmt_NT] = c + 0;
			p->rule.sparc_stmt = 21;
		}
		break;
	case 39:  /* ARGP */
		assert(l);
		c = l->cost[sparc_reg_NT] + 1;
		if (c + 0 < p->cost[sparc_stmt_NT]) {  /* stmt : ARGP(reg) */
			p->cost[sparc_stmt_NT] = c + 0;
			p->rule.sparc_stmt = 22;
		}
		break;
	case 57:  /* ASGNB */
		assert(l && r);
		c = l->cost[sparc_reg_NT] + r->cost[sparc_reg_NT] + 0;
		if (c + 0 < p->cost[sparc_stmt_NT]) {  /* stmt : ASGNB(reg,reg) */
			p->cost[sparc_stmt_NT] = c + 0;
			p->rule.sparc_stmt = 3;
		}
		break;
	case 51:  /* ASGNC */
		assert(l && r);
		c = l->cost[sparc_addr_NT] + r->cost[sparc_reg_NT] + 1;
		if (c + 0 < p->cost[sparc_stmt_NT]) {  /* stmt : ASGNC(addr,reg) */
			p->cost[sparc_stmt_NT] = c + 0;
			p->rule.sparc_stmt = 27;
		}
		if (
			l->op == 615 /* VREGP */
		) {
			c = r->cost[sparc_reg_NT] + 0;
			if (c + 0 < p->cost[sparc_stmt_NT]) {  /* stmt : ASGNC(VREGP,reg) */
				p->cost[sparc_stmt_NT] = c + 0;
				p->rule.sparc_stmt = 33;
			}
		}
		break;
	case 50:  /* ASGND */
		assert(l && r);
		c = l->cost[sparc_addr_NT] + r->cost[sparc_reg_NT] + 1;
		if (c + 0 < p->cost[sparc_stmt_NT]) {  /* stmt : ASGND(addr,reg) */
			p->cost[sparc_stmt_NT] = c + 0;
			p->rule.sparc_stmt = 24;
		}
		if (
			l->op == 615 /* VREGP */
		) {
			c = r->cost[sparc_reg_NT] + 0;
			if (c + 0 < p->cost[sparc_stmt_NT]) {  /* stmt : ASGND(VREGP,reg) */
				p->cost[sparc_stmt_NT] = c + 0;
				p->rule.sparc_stmt = 30;
			}
		}
		break;
	case 49:  /* ASGNF */
		assert(l && r);
		c = l->cost[sparc_addr_NT] + r->cost[sparc_reg_NT] + 1;
		if (c + 0 < p->cost[sparc_stmt_NT]) {  /* stmt : ASGNF(addr,reg) */
			p->cost[sparc_stmt_NT] = c + 0;
			p->rule.sparc_stmt = 23;
		}
		if (
			l->op == 615 /* VREGP */
		) {
			c = r->cost[sparc_reg_NT] + 0;
			if (c + 0 < p->cost[sparc_stmt_NT]) {  /* stmt : ASGNF(VREGP,reg) */
				p->cost[sparc_stmt_NT] = c + 0;
				p->rule.sparc_stmt = 29;
			}
		}
		break;
	case 53:  /* ASGNI */
		assert(l && r);
		c = l->cost[sparc_addr_NT] + r->cost[sparc_reg_NT] + 1;
		if (c + 0 < p->cost[sparc_stmt_NT]) {  /* stmt : ASGNI(addr,reg) */
			p->cost[sparc_stmt_NT] = c + 0;
			p->rule.sparc_stmt = 25;
		}
		if (
			l->op == 615 /* VREGP */
		) {
			c = r->cost[sparc_reg_NT] + 0;
			if (c + 0 < p->cost[sparc_stmt_NT]) {  /* stmt : ASGNI(VREGP,reg) */
				p->cost[sparc_stmt_NT] = c + 0;
				p->rule.sparc_stmt = 31;
			}
		}
		break;
	case 55:  /* ASGNP */
		assert(l && r);
		c = l->cost[sparc_addr_NT] + r->cost[sparc_reg_NT] + 1;
		if (c + 0 < p->cost[sparc_stmt_NT]) {  /* stmt : ASGNP(addr,reg) */
			p->cost[sparc_stmt_NT] = c + 0;
			p->rule.sparc_stmt = 26;
		}
		if (
			l->op == 615 /* VREGP */
		) {
			c = r->cost[sparc_reg_NT] + 0;
			if (c + 0 < p->cost[sparc_stmt_NT]) {  /* stmt : ASGNP(VREGP,reg) */
				p->cost[sparc_stmt_NT] = c + 0;
				p->rule.sparc_stmt = 32;
			}
		}
		break;
	case 52:  /* ASGNS */
		assert(l && r);
		c = l->cost[sparc_addr_NT] + r->cost[sparc_reg_NT] + 1;
		if (c + 0 < p->cost[sparc_stmt_NT]) {  /* stmt : ASGNS(addr,reg) */
			p->cost[sparc_stmt_NT] = c + 0;
			p->rule.sparc_stmt = 28;
		}
		if (
			l->op == 615 /* VREGP */
		) {
			c = r->cost[sparc_reg_NT] + 0;
			if (c + 0 < p->cost[sparc_stmt_NT]) {  /* stmt : ASGNS(VREGP,reg) */
				p->cost[sparc_stmt_NT] = c + 0;
				p->rule.sparc_stmt = 34;
			}
		}
		break;
	case 390:  /* BANDU */
		assert(l && r);
		if (
			r->op == 406 /* BCOMU */
		) {
			c = l->cost[sparc_reg_NT] + r->left->cost[sparc_rc_NT] + 1;
			if (c + 0 < p->cost[sparc_reg_NT]) {  /* reg : BANDU(reg,BCOMU(rc)) */
				p->cost[sparc_reg_NT] = c + 0;
				p->rule.sparc_reg = 34;
				sparc_closure_reg(p, c + 0);
			}
		}
		c = l->cost[sparc_reg_NT] + r->cost[sparc_rc_NT] + 1;
		if (c + 0 < p->cost[sparc_reg_NT]) {  /* reg : BANDU(reg,rc) */
			p->cost[sparc_reg_NT] = c + 0;
			p->rule.sparc_reg = 36;
			sparc_closure_reg(p, c + 0);
		}
		break;
	case 406:  /* BCOMU */
		assert(l);
		c = l->cost[sparc_reg_NT] + 1;
		if (c + 0 < p->cost[sparc_reg_NT]) {  /* reg : BCOMU(reg) */
			p->cost[sparc_reg_NT] = c + 0;
			p->rule.sparc_reg = 2;
			sparc_closure_reg(p, c + 0);
		}
		break;
	case 422:  /* BORU */
		assert(l && r);
		if (
			r->op == 406 /* BCOMU */
		) {
			c = l->cost[sparc_reg_NT] + r->left->cost[sparc_rc_NT] + 1;
			if (c + 0 < p->cost[sparc_reg_NT]) {  /* reg : BORU(reg,BCOMU(rc)) */
				p->cost[sparc_reg_NT] = c + 0;
				p->rule.sparc_reg = 35;
				sparc_closure_reg(p, c + 0);
			}
		}
		c = l->cost[sparc_reg_NT] + r->cost[sparc_rc_NT] + 1;
		if (c + 0 < p->cost[sparc_reg_NT]) {  /* reg : BORU(reg,rc) */
			p->cost[sparc_reg_NT] = c + 0;
			p->rule.sparc_reg = 37;
			sparc_closure_reg(p, c + 0);
		}
		break;
	case 438:  /* BXORU */
		assert(l && r);
		if (
			r->op == 406 /* BCOMU */
		) {
			c = l->cost[sparc_reg_NT] + r->left->cost[sparc_rc_NT] + 1;
			if (c + 0 < p->cost[sparc_reg_NT]) {  /* reg : BXORU(reg,BCOMU(rc)) */
				p->cost[sparc_reg_NT] = c + 0;
				p->rule.sparc_reg = 3;
				sparc_closure_reg(p, c + 0);
			}
		}
		c = l->cost[sparc_reg_NT] + r->cost[sparc_rc_NT] + 1;
		if (c + 0 < p->cost[sparc_reg_NT]) {  /* reg : BXORU(reg,rc) */
			p->cost[sparc_reg_NT] = c + 0;
			p->rule.sparc_reg = 4;
			sparc_closure_reg(p, c + 0);
		}
		break;
	case 217:  /* CALLB */
		assert(l && r);
		c = l->cost[sparc_ar_NT] + r->cost[sparc_reg_NT] + 2;
		if (c + 0 < p->cost[sparc_stmt_NT]) {  /* stmt : CALLB(ar,reg) */
			p->cost[sparc_stmt_NT] = c + 0;
			p->rule.sparc_stmt = 4;
		}
		break;
	case 210:  /* CALLD */
		assert(l);
		c = l->cost[sparc_ar_NT] + 2;
		if (c + 0 < p->cost[sparc_reg_NT]) {  /* reg : CALLD(ar) */
			p->cost[sparc_reg_NT] = c + 0;
			p->rule.sparc_reg = 5;
			sparc_closure_reg(p, c + 0);
		}
		break;
	case 209:  /* CALLF */
		assert(l);
		c = l->cost[sparc_ar_NT] + 2;
		if (c + 0 < p->cost[sparc_reg_NT]) {  /* reg : CALLF(ar) */
			p->cost[sparc_reg_NT] = c + 0;
			p->rule.sparc_reg = 6;
			sparc_closure_reg(p, c + 0);
		}
		break;
	case 213:  /* CALLI */
		assert(l);
		c = l->cost[sparc_ar_NT] + 2;
		if (c + 0 < p->cost[sparc_reg_NT]) {  /* reg : CALLI(ar) */
			p->cost[sparc_reg_NT] = c + 0;
			p->rule.sparc_reg = 7;
			sparc_closure_reg(p, c + 0);
		}
		break;
	case 216:  /* CALLV */
		assert(l);
		c = l->cost[sparc_ar_NT] + 2;
		if (c + 0 < p->cost[sparc_stmt_NT]) {  /* stmt : CALLV(ar) */
			p->cost[sparc_stmt_NT] = c + 0;
			p->rule.sparc_stmt = 5;
		}
		break;
	case 19:  /* CNSTC */
		{
			static struct sparc_state z = { 19, 0, 0,
				{	0,
					1,	/* stmt: reg */
					0,	/* acon: con */
					0,	/* addr: acon */
					0,	/* ar: acon */
					0,	/* con: CNSTC */
					0,	/* rc: con */
					1,	/* reg: con */
				},{
					10,	/* stmt: reg */
					2,	/* acon: con */
					3,	/* addr: acon */
					1,	/* ar: acon */
					4,	/* con: CNSTC */
					1,	/* rc: con */
					25,	/* reg: con */
				}
			};
			return (int)&z;
		}
	case 18:  /* CNSTD */
		{
			static struct sparc_state z = { 18, 0, 0,
				{	0,
					0x7fff,
					0x7fff,
					0x7fff,
					0x7fff,
					0x7fff,
					0x7fff,
					0x7fff,
				},{
					0,
					0,
					0,
					0,
					0,
					0,
					0,
				}
			};
			return (int)&z;
		}
	case 17:  /* CNSTF */
		{
			static struct sparc_state z = { 17, 0, 0,
				{	0,
					0x7fff,
					0x7fff,
					0x7fff,
					0x7fff,
					0x7fff,
					0x7fff,
					0x7fff,
				},{
					0,
					0,
					0,
					0,
					0,
					0,
					0,
				}
			};
			return (int)&z;
		}
	case 21:  /* CNSTI */
		{
			static struct sparc_state z = { 21, 0, 0,
				{	0,
					1,	/* stmt: reg */
					0,	/* acon: con */
					0,	/* addr: acon */
					0,	/* ar: acon */
					0,	/* con: CNSTI */
					0,	/* rc: con */
					1,	/* reg: con */
				},{
					10,	/* stmt: reg */
					2,	/* acon: con */
					3,	/* addr: acon */
					1,	/* ar: acon */
					1,	/* con: CNSTI */
					1,	/* rc: con */
					25,	/* reg: con */
				}
			};
			return (int)&z;
		}
	case 23:  /* CNSTP */
		{
			static struct sparc_state z = { 23, 0, 0,
				{	0,
					1,	/* stmt: reg */
					0,	/* acon: con */
					0,	/* addr: acon */
					0,	/* ar: acon */
					0,	/* con: CNSTP */
					0,	/* rc: con */
					1,	/* reg: con */
				},{
					10,	/* stmt: reg */
					2,	/* acon: con */
					3,	/* addr: acon */
					1,	/* ar: acon */
					2,	/* con: CNSTP */
					1,	/* rc: con */
					25,	/* reg: con */
				}
			};
			return (int)&z;
		}
	case 20:  /* CNSTS */
		{
			static struct sparc_state z = { 20, 0, 0,
				{	0,
					1,	/* stmt: reg */
					0,	/* acon: con */
					0,	/* addr: acon */
					0,	/* ar: acon */
					0,	/* con: CNSTS */
					0,	/* rc: con */
					1,	/* reg: con */
				},{
					10,	/* stmt: reg */
					2,	/* acon: con */
					3,	/* addr: acon */
					1,	/* ar: acon */
					5,	/* con: CNSTS */
					1,	/* rc: con */
					25,	/* reg: con */
				}
			};
			return (int)&z;
		}
	case 22:  /* CNSTU */
		{
			static struct sparc_state z = { 22, 0, 0,
				{	0,
					1,	/* stmt: reg */
					0,	/* acon: con */
					0,	/* addr: acon */
					0,	/* ar: acon */
					0,	/* con: CNSTU */
					0,	/* rc: con */
					1,	/* reg: con */
				},{
					10,	/* stmt: reg */
					2,	/* acon: con */
					3,	/* addr: acon */
					1,	/* ar: acon */
					3,	/* con: CNSTU */
					1,	/* rc: con */
					25,	/* reg: con */
				}
			};
			return (int)&z;
		}
	case 85:  /* CVCI */
		assert(l);
		if (
			l->op == 67 /* INDIRC */
		) {
			c = l->left->cost[sparc_addr_NT] + 1;
			if (c + 0 < p->cost[sparc_reg_NT]) {  /* reg : CVCI(INDIRC(addr)) */
				p->cost[sparc_reg_NT] = c + 0;
				p->rule.sparc_reg = 8;
				sparc_closure_reg(p, c + 0);
			}
		}
		c = l->cost[sparc_reg_NT] + 1;
		if (c + 0 < p->cost[sparc_reg_NT]) {  /* reg : CVCI(reg) */
			p->cost[sparc_reg_NT] = c + 0;
			p->rule.sparc_reg = 9;
			sparc_closure_reg(p, c + 0);
		}
		break;
	case 86:  /* CVCU */
		assert(l);
		if (
			l->op == 67 /* INDIRC */
		) {
			c = l->left->cost[sparc_addr_NT] + 1;
			if (c + 0 < p->cost[sparc_reg_NT]) {  /* reg : CVCU(INDIRC(addr)) */
				p->cost[sparc_reg_NT] = c + 0;
				p->rule.sparc_reg = 10;
				sparc_closure_reg(p, c + 0);
			}
		}
		c = l->cost[sparc_reg_NT] + 1;
		if (c + 0 < p->cost[sparc_reg_NT]) {  /* reg : CVCU(reg) */
			p->cost[sparc_reg_NT] = c + 0;
			p->rule.sparc_reg = 11;
			sparc_closure_reg(p, c + 0);
		}
		break;
	case 97:  /* CVDF */
		assert(l);
		c = l->cost[sparc_reg_NT] + 1;
		if (c + 0 < p->cost[sparc_reg_NT]) {  /* reg : CVDF(reg) */
			p->cost[sparc_reg_NT] = c + 0;
			p->rule.sparc_reg = 12;
			sparc_closure_reg(p, c + 0);
		}
		break;
	case 101:  /* CVDI */
		assert(l);
		c = l->cost[sparc_reg_NT] + 1;
		if (c + 0 < p->cost[sparc_reg_NT]) {  /* reg : CVDI(reg) */
			p->cost[sparc_reg_NT] = c + 0;
			p->rule.sparc_reg = 13;
			sparc_closure_reg(p, c + 0);
		}
		break;
	case 114:  /* CVFD */
		assert(l);
		c = l->cost[sparc_reg_NT] + 1;
		if (c + 0 < p->cost[sparc_reg_NT]) {  /* reg : CVFD(reg) */
			p->cost[sparc_reg_NT] = c + 0;
			p->rule.sparc_reg = 14;
			sparc_closure_reg(p, c + 0);
		}
		break;
	case 131:  /* CVIC */
		assert(l);
		c = l->cost[sparc_reg_NT] + 1;
		if (c + 0 < p->cost[sparc_reg_NT]) {  /* reg : CVIC(reg) */
			p->cost[sparc_reg_NT] = c + 0;
			p->rule.sparc_reg = 38;
			sparc_closure_reg(p, c + 0);
		}
		break;
	case 130:  /* CVID */
		assert(l);
		c = l->cost[sparc_reg_NT] + 1;
		if (c + 0 < p->cost[sparc_reg_NT]) {  /* reg : CVID(reg) */
			p->cost[sparc_reg_NT] = c + 0;
			p->rule.sparc_reg = 15;
			sparc_closure_reg(p, c + 0);
		}
		break;
	case 132:  /* CVIS */
		assert(l);
		c = l->cost[sparc_reg_NT] + 1;
		if (c + 0 < p->cost[sparc_reg_NT]) {  /* reg : CVIS(reg) */
			p->cost[sparc_reg_NT] = c + 0;
			p->rule.sparc_reg = 39;
			sparc_closure_reg(p, c + 0);
		}
		break;
	case 134:  /* CVIU */
		assert(l);
		c = l->cost[sparc_reg_NT] + 1;
		if (c + 0 < p->cost[sparc_reg_NT]) {  /* reg : CVIU(reg) */
			p->cost[sparc_reg_NT] = c + 0;
			p->rule.sparc_reg = 40;
			sparc_closure_reg(p, c + 0);
		}
		break;
	case 150:  /* CVPU */
		assert(l);
		c = l->cost[sparc_reg_NT] + 1;
		if (c + 0 < p->cost[sparc_reg_NT]) {  /* reg : CVPU(reg) */
			p->cost[sparc_reg_NT] = c + 0;
			p->rule.sparc_reg = 44;
			sparc_closure_reg(p, c + 0);
		}
		break;
	case 165:  /* CVSI */
		assert(l);
		if (
			l->op == 68 /* INDIRS */
		) {
			c = l->left->cost[sparc_addr_NT] + 1;
			if (c + 0 < p->cost[sparc_reg_NT]) {  /* reg : CVSI(INDIRS(addr)) */
				p->cost[sparc_reg_NT] = c + 0;
				p->rule.sparc_reg = 16;
				sparc_closure_reg(p, c + 0);
			}
		}
		c = l->cost[sparc_reg_NT] + 1;
		if (c + 0 < p->cost[sparc_reg_NT]) {  /* reg : CVSI(reg) */
			p->cost[sparc_reg_NT] = c + 0;
			p->rule.sparc_reg = 17;
			sparc_closure_reg(p, c + 0);
		}
		break;
	case 166:  /* CVSU */
		assert(l);
		if (
			l->op == 68 /* INDIRS */
		) {
			c = l->left->cost[sparc_addr_NT] + 1;
			if (c + 0 < p->cost[sparc_reg_NT]) {  /* reg : CVSU(INDIRS(addr)) */
				p->cost[sparc_reg_NT] = c + 0;
				p->rule.sparc_reg = 18;
				sparc_closure_reg(p, c + 0);
			}
		}
		c = l->cost[sparc_reg_NT] + 1;
		if (c + 0 < p->cost[sparc_reg_NT]) {  /* reg : CVSU(reg) */
			p->cost[sparc_reg_NT] = c + 0;
			p->rule.sparc_reg = 19;
			sparc_closure_reg(p, c + 0);
		}
		break;
	case 179:  /* CVUC */
		assert(l);
		c = l->cost[sparc_reg_NT] + 1;
		if (c + 0 < p->cost[sparc_reg_NT]) {  /* reg : CVUC(reg) */
			p->cost[sparc_reg_NT] = c + 0;
			p->rule.sparc_reg = 41;
			sparc_closure_reg(p, c + 0);
		}
		break;
	case 181:  /* CVUI */
		assert(l);
		c = l->cost[sparc_reg_NT] + 1;
		if (c + 0 < p->cost[sparc_reg_NT]) {  /* reg : CVUI(reg) */
			p->cost[sparc_reg_NT] = c + 0;
			p->rule.sparc_reg = 43;
			sparc_closure_reg(p, c + 0);
		}
		break;
	case 183:  /* CVUP */
		assert(l);
		c = l->cost[sparc_reg_NT] + 1;
		if (c + 0 < p->cost[sparc_reg_NT]) {  /* reg : CVUP(reg) */
			p->cost[sparc_reg_NT] = c + 0;
			p->rule.sparc_reg = 45;
			sparc_closure_reg(p, c + 0);
		}
		break;
	case 180:  /* CVUS */
		assert(l);
		c = l->cost[sparc_reg_NT] + 1;
		if (c + 0 < p->cost[sparc_reg_NT]) {  /* reg : CVUS(reg) */
			p->cost[sparc_reg_NT] = c + 0;
			p->rule.sparc_reg = 42;
			sparc_closure_reg(p, c + 0);
		}
		break;
	case 450:  /* DIVD */
		assert(l && r);
		c = l->cost[sparc_reg_NT] + r->cost[sparc_reg_NT] + 1;
		if (c + 0 < p->cost[sparc_reg_NT]) {  /* reg : DIVD(reg,reg) */
			p->cost[sparc_reg_NT] = c + 0;
			p->rule.sparc_reg = 33;
			sparc_closure_reg(p, c + 0);
		}
		break;
	case 449:  /* DIVF */
		assert(l && r);
		c = l->cost[sparc_reg_NT] + r->cost[sparc_reg_NT] + 1;
		if (c + 0 < p->cost[sparc_reg_NT]) {  /* reg : DIVF(reg,reg) */
			p->cost[sparc_reg_NT] = c + 0;
			p->rule.sparc_reg = 32;
			sparc_closure_reg(p, c + 0);
		}
		break;
	case 453:  /* DIVI */
		assert(l && r);
		c = l->cost[sparc_reg_NT] + r->cost[sparc_reg_NT] + 1;
		if (c + 0 < p->cost[sparc_reg_NT]) {  /* reg : DIVI(reg,reg) */
			p->cost[sparc_reg_NT] = c + 0;
			p->rule.sparc_reg = 53;
			sparc_closure_reg(p, c + 0);
		}
		break;
	case 454:  /* DIVU */
		assert(l && r);
		c = l->cost[sparc_reg_NT] + r->cost[sparc_reg_NT] + 1;
		if (c + 0 < p->cost[sparc_reg_NT]) {  /* reg : DIVU(reg,reg) */
			p->cost[sparc_reg_NT] = c + 0;
			p->rule.sparc_reg = 54;
			sparc_closure_reg(p, c + 0);
		}
		break;
	case 482:  /* EQD */
		{
			static struct sparc_state z = { 482, 0, 0,
				{	0,
					0x7fff,
					0x7fff,
					0x7fff,
					0x7fff,
					0x7fff,
					0x7fff,
					0x7fff,
				},{
					0,
					0,
					0,
					0,
					0,
					0,
					0,
				}
			};
			return (int)&z;
		}
	case 481:  /* EQF */
		{
			static struct sparc_state z = { 481, 0, 0,
				{	0,
					0x7fff,
					0x7fff,
					0x7fff,
					0x7fff,
					0x7fff,
					0x7fff,
					0x7fff,
				},{
					0,
					0,
					0,
					0,
					0,
					0,
					0,
				}
			};
			return (int)&z;
		}
	case 485:  /* EQI */
		assert(l && r);
		c = l->cost[sparc_reg_NT] + r->cost[sparc_rc_NT] + 1;
		if (c + 0 < p->cost[sparc_stmt_NT]) {  /* stmt : EQI(reg,rc) */
			p->cost[sparc_stmt_NT] = c + 0;
			p->rule.sparc_stmt = 11;
		}
		break;
	case 498:  /* GED */
		{
			static struct sparc_state z = { 498, 0, 0,
				{	0,
					0x7fff,
					0x7fff,
					0x7fff,
					0x7fff,
					0x7fff,
					0x7fff,
					0x7fff,
				},{
					0,
					0,
					0,
					0,
					0,
					0,
					0,
				}
			};
			return (int)&z;
		}
	case 497:  /* GEF */
		{
			static struct sparc_state z = { 497, 0, 0,
				{	0,
					0x7fff,
					0x7fff,
					0x7fff,
					0x7fff,
					0x7fff,
					0x7fff,
					0x7fff,
				},{
					0,
					0,
					0,
					0,
					0,
					0,
					0,
				}
			};
			return (int)&z;
		}
	case 501:  /* GEI */
		assert(l && r);
		c = l->cost[sparc_reg_NT] + r->cost[sparc_rc_NT] + 1;
		if (c + 0 < p->cost[sparc_stmt_NT]) {  /* stmt : GEI(reg,rc) */
			p->cost[sparc_stmt_NT] = c + 0;
			p->rule.sparc_stmt = 14;
		}
		break;
	case 502:  /* GEU */
		assert(l && r);
		c = l->cost[sparc_reg_NT] + r->cost[sparc_rc_NT] + 1;
		if (c + 0 < p->cost[sparc_stmt_NT]) {  /* stmt : GEU(reg,rc) */
			p->cost[sparc_stmt_NT] = c + 0;
			p->rule.sparc_stmt = 18;
		}
		break;
	case 514:  /* GTD */
		{
			static struct sparc_state z = { 514, 0, 0,
				{	0,
					0x7fff,
					0x7fff,
					0x7fff,
					0x7fff,
					0x7fff,
					0x7fff,
					0x7fff,
				},{
					0,
					0,
					0,
					0,
					0,
					0,
					0,
				}
			};
			return (int)&z;
		}
	case 513:  /* GTF */
		{
			static struct sparc_state z = { 513, 0, 0,
				{	0,
					0x7fff,
					0x7fff,
					0x7fff,
					0x7fff,
					0x7fff,
					0x7fff,
					0x7fff,
				},{
					0,
					0,
					0,
					0,
					0,
					0,
					0,
				}
			};
			return (int)&z;
		}
	case 517:  /* GTI */
		assert(l && r);
		c = l->cost[sparc_reg_NT] + r->cost[sparc_rc_NT] + 1;
		if (c + 0 < p->cost[sparc_stmt_NT]) {  /* stmt : GTI(reg,rc) */
			p->cost[sparc_stmt_NT] = c + 0;
			p->rule.sparc_stmt = 13;
		}
		break;
	case 518:  /* GTU */
		assert(l && r);
		c = l->cost[sparc_reg_NT] + r->cost[sparc_rc_NT] + 1;
		if (c + 0 < p->cost[sparc_stmt_NT]) {  /* stmt : GTU(reg,rc) */
			p->cost[sparc_stmt_NT] = c + 0;
			p->rule.sparc_stmt = 17;
		}
		break;
	case 661:  /* I0I */
		{
			static struct sparc_state z = { 661, 0, 0,
				{	0,
					0,	/* stmt: reg */
					0,	/* acon: con */
					0,	/* addr: acon */
					0,	/* ar: acon */
					0,	/* con: I0I */
					0,	/* rc: con */
					0,	/* reg: I0I */
				},{
					10,	/* stmt: reg */
					2,	/* acon: con */
					3,	/* addr: acon */
					1,	/* ar: acon */
					6,	/* con: I0I */
					1,	/* rc: con */
					59,	/* reg: I0I */
				}
			};
			return (int)&z;
		}
	case 677:  /* I1I */
		{
			static struct sparc_state z = { 677, 0, 0,
				{	0,
					1,	/* stmt: reg */
					0,	/* acon: con */
					0,	/* addr: acon */
					0,	/* ar: acon */
					0,	/* con: I1I */
					0,	/* rc: con */
					1,	/* reg: con */
				},{
					10,	/* stmt: reg */
					2,	/* acon: con */
					3,	/* addr: acon */
					1,	/* ar: acon */
					7,	/* con: I1I */
					1,	/* rc: con */
					25,	/* reg: con */
				}
			};
			return (int)&z;
		}
	case 693:  /* I2I */
		{
			static struct sparc_state z = { 693, 0, 0,
				{	0,
					1,	/* stmt: reg */
					0,	/* acon: con */
					0,	/* addr: acon */
					0,	/* ar: acon */
					0,	/* con: I2I */
					0,	/* rc: con */
					1,	/* reg: con */
				},{
					10,	/* stmt: reg */
					2,	/* acon: con */
					3,	/* addr: acon */
					1,	/* ar: acon */
					8,	/* con: I2I */
					1,	/* rc: con */
					25,	/* reg: con */
				}
			};
			return (int)&z;
		}
	case 709:  /* I3I */
		{
			static struct sparc_state z = { 709, 0, 0,
				{	0,
					1,	/* stmt: reg */
					0,	/* acon: con */
					0,	/* addr: acon */
					0,	/* ar: acon */
					0,	/* con: I3I */
					0,	/* rc: con */
					1,	/* reg: con */
				},{
					10,	/* stmt: reg */
					2,	/* acon: con */
					3,	/* addr: acon */
					1,	/* ar: acon */
					9,	/* con: I3I */
					1,	/* rc: con */
					25,	/* reg: con */
				}
			};
			return (int)&z;
		}
	case 73:  /* INDIRB */
		assert(l);
		c = l->cost[sparc_reg_NT] + 1;
		if (c + 0 < p->cost[sparc_reg_NT]) {  /* reg : INDIRB(reg) */
			p->cost[sparc_reg_NT] = c + 0;
			p->rule.sparc_reg = 46;
			sparc_closure_reg(p, c + 0);
		}
		break;
	case 67:  /* INDIRC */
		assert(l);
		c = l->cost[sparc_addr_NT] + 1;
		if (c + 0 < p->cost[sparc_reg_NT]) {  /* reg : INDIRC(addr) */
			p->cost[sparc_reg_NT] = c + 0;
			p->rule.sparc_reg = 64;
			sparc_closure_reg(p, c + 0);
		}
		if (
			l->op == 615 /* VREGP */
		) {
			c = 0;
			if (c + 0 < p->cost[sparc_reg_NT]) {  /* reg : INDIRC(VREGP) */
				p->cost[sparc_reg_NT] = c + 0;
				p->rule.sparc_reg = 70;
				sparc_closure_reg(p, c + 0);
			}
		}
		break;
	case 66:  /* INDIRD */
		assert(l);
		c = l->cost[sparc_addr_NT] + 1;
		if (c + 0 < p->cost[sparc_reg_NT]) {  /* reg : INDIRD(addr) */
			p->cost[sparc_reg_NT] = c + 0;
			p->rule.sparc_reg = 61;
			sparc_closure_reg(p, c + 0);
		}
		if (
			l->op == 615 /* VREGP */
		) {
			c = 0;
			if (c + 0 < p->cost[sparc_reg_NT]) {  /* reg : INDIRD(VREGP) */
				p->cost[sparc_reg_NT] = c + 0;
				p->rule.sparc_reg = 67;
				sparc_closure_reg(p, c + 0);
			}
		}
		break;
	case 65:  /* INDIRF */
		assert(l);
		c = l->cost[sparc_addr_NT] + 1;
		if (c + 0 < p->cost[sparc_reg_NT]) {  /* reg : INDIRF(addr) */
			p->cost[sparc_reg_NT] = c + 0;
			p->rule.sparc_reg = 60;
			sparc_closure_reg(p, c + 0);
		}
		if (
			l->op == 615 /* VREGP */
		) {
			c = 0;
			if (c + 0 < p->cost[sparc_reg_NT]) {  /* reg : INDIRF(VREGP) */
				p->cost[sparc_reg_NT] = c + 0;
				p->rule.sparc_reg = 66;
				sparc_closure_reg(p, c + 0);
			}
		}
		break;
	case 69:  /* INDIRI */
		assert(l);
		c = l->cost[sparc_addr_NT] + 1;
		if (c + 0 < p->cost[sparc_reg_NT]) {  /* reg : INDIRI(addr) */
			p->cost[sparc_reg_NT] = c + 0;
			p->rule.sparc_reg = 62;
			sparc_closure_reg(p, c + 0);
		}
		if (
			l->op == 615 /* VREGP */
		) {
			c = 0;
			if (c + 0 < p->cost[sparc_reg_NT]) {  /* reg : INDIRI(VREGP) */
				p->cost[sparc_reg_NT] = c + 0;
				p->rule.sparc_reg = 68;
				sparc_closure_reg(p, c + 0);
			}
		}
		break;
	case 71:  /* INDIRP */
		assert(l);
		c = l->cost[sparc_addr_NT] + 1;
		if (c + 0 < p->cost[sparc_reg_NT]) {  /* reg : INDIRP(addr) */
			p->cost[sparc_reg_NT] = c + 0;
			p->rule.sparc_reg = 63;
			sparc_closure_reg(p, c + 0);
		}
		if (
			l->op == 615 /* VREGP */
		) {
			c = 0;
			if (c + 0 < p->cost[sparc_reg_NT]) {  /* reg : INDIRP(VREGP) */
				p->cost[sparc_reg_NT] = c + 0;
				p->rule.sparc_reg = 69;
				sparc_closure_reg(p, c + 0);
			}
		}
		break;
	case 68:  /* INDIRS */
		assert(l);
		c = l->cost[sparc_addr_NT] + 1;
		if (c + 0 < p->cost[sparc_reg_NT]) {  /* reg : INDIRS(addr) */
			p->cost[sparc_reg_NT] = c + 0;
			p->rule.sparc_reg = 65;
			sparc_closure_reg(p, c + 0);
		}
		if (
			l->op == 615 /* VREGP */
		) {
			c = 0;
			if (c + 0 < p->cost[sparc_reg_NT]) {  /* reg : INDIRS(VREGP) */
				p->cost[sparc_reg_NT] = c + 0;
				p->rule.sparc_reg = 71;
				sparc_closure_reg(p, c + 0);
			}
		}
		break;
	case 584:  /* JUMPV */
		assert(l);
		c = l->cost[sparc_acon_NT] + 1;
		if (c + 0 < p->cost[sparc_stmt_NT]) {  /* stmt : JUMPV(acon) */
			p->cost[sparc_stmt_NT] = c + 0;
			p->rule.sparc_stmt = 6;
		}
		c = l->cost[sparc_addr_NT] + 1;
		if (c + 0 < p->cost[sparc_stmt_NT]) {  /* stmt : JUMPV(addr) */
			p->cost[sparc_stmt_NT] = c + 0;
			p->rule.sparc_stmt = 7;
		}
		break;
	case 600:  /* LABELV */
		{
			static struct sparc_state z = { 600, 0, 0,
				{	0,
					0,	/* stmt: LABELV */
					0x7fff,
					0x7fff,
					0x7fff,
					0x7fff,
					0x7fff,
					0x7fff,
				},{
					8,	/* stmt: LABELV */
					0,
					0,
					0,
					0,
					0,
					0,
				}
			};
			return (int)&z;
		}
	case 530:  /* LED */
		{
			static struct sparc_state z = { 530, 0, 0,
				{	0,
					0x7fff,
					0x7fff,
					0x7fff,
					0x7fff,
					0x7fff,
					0x7fff,
					0x7fff,
				},{
					0,
					0,
					0,
					0,
					0,
					0,
					0,
				}
			};
			return (int)&z;
		}
	case 529:  /* LEF */
		{
			static struct sparc_state z = { 529, 0, 0,
				{	0,
					0x7fff,
					0x7fff,
					0x7fff,
					0x7fff,
					0x7fff,
					0x7fff,
					0x7fff,
				},{
					0,
					0,
					0,
					0,
					0,
					0,
					0,
				}
			};
			return (int)&z;
		}
	case 533:  /* LEI */
		assert(l && r);
		c = l->cost[sparc_reg_NT] + r->cost[sparc_rc_NT] + 1;
		if (c + 0 < p->cost[sparc_stmt_NT]) {  /* stmt : LEI(reg,rc) */
			p->cost[sparc_stmt_NT] = c + 0;
			p->rule.sparc_stmt = 16;
		}
		break;
	case 534:  /* LEU */
		assert(l && r);
		c = l->cost[sparc_reg_NT] + r->cost[sparc_rc_NT] + 1;
		if (c + 0 < p->cost[sparc_stmt_NT]) {  /* stmt : LEU(reg,rc) */
			p->cost[sparc_stmt_NT] = c + 0;
			p->rule.sparc_stmt = 20;
		}
		break;
	case 233:  /* LOADB */
		assert(l);
		c = l->cost[sparc_reg_NT] + 1;
		if (c + 0 < p->cost[sparc_reg_NT]) {  /* reg : LOADB(reg) */
			p->cost[sparc_reg_NT] = c + 0;
			p->rule.sparc_reg = 52;
			sparc_closure_reg(p, c + 0);
		}
		break;
	case 227:  /* LOADC */
		assert(l);
		c = l->cost[sparc_reg_NT] + 1;
		if (c + 0 < p->cost[sparc_reg_NT]) {  /* reg : LOADC(reg) */
			p->cost[sparc_reg_NT] = c + 0;
			p->rule.sparc_reg = 47;
			sparc_closure_reg(p, c + 0);
		}
		break;
	case 226:  /* LOADD */
		assert(l);
		c = l->cost[sparc_reg_NT] + 1;
		if (c + 0 < p->cost[sparc_reg_NT]) {  /* reg : LOADD(reg) */
			p->cost[sparc_reg_NT] = c + 0;
			p->rule.sparc_reg = 20;
			sparc_closure_reg(p, c + 0);
		}
		break;
	case 225:  /* LOADF */
		assert(l);
		c = l->cost[sparc_reg_NT] + 1;
		if (c + 0 < p->cost[sparc_reg_NT]) {  /* reg : LOADF(reg) */
			p->cost[sparc_reg_NT] = c + 0;
			p->rule.sparc_reg = 21;
			sparc_closure_reg(p, c + 0);
		}
		break;
	case 229:  /* LOADI */
		assert(l);
		c = l->cost[sparc_reg_NT] + 1;
		if (c + 0 < p->cost[sparc_reg_NT]) {  /* reg : LOADI(reg) */
			p->cost[sparc_reg_NT] = c + 0;
			p->rule.sparc_reg = 49;
			sparc_closure_reg(p, c + 0);
		}
		break;
	case 231:  /* LOADP */
		assert(l);
		c = l->cost[sparc_reg_NT] + 1;
		if (c + 0 < p->cost[sparc_reg_NT]) {  /* reg : LOADP(reg) */
			p->cost[sparc_reg_NT] = c + 0;
			p->rule.sparc_reg = 50;
			sparc_closure_reg(p, c + 0);
		}
		break;
	case 228:  /* LOADS */
		assert(l);
		c = l->cost[sparc_reg_NT] + 1;
		if (c + 0 < p->cost[sparc_reg_NT]) {  /* reg : LOADS(reg) */
			p->cost[sparc_reg_NT] = c + 0;
			p->rule.sparc_reg = 48;
			sparc_closure_reg(p, c + 0);
		}
		break;
	case 230:  /* LOADU */
		assert(l);
		c = l->cost[sparc_reg_NT] + 1;
		if (c + 0 < p->cost[sparc_reg_NT]) {  /* reg : LOADU(reg) */
			p->cost[sparc_reg_NT] = c + 0;
			p->rule.sparc_reg = 51;
			sparc_closure_reg(p, c + 0);
		}
		break;
	case 341:  /* LSHI */
		assert(l && r);
		c = l->cost[sparc_reg_NT] + r->cost[sparc_rc_NT] + 1;
		if (c + 0 < p->cost[sparc_reg_NT]) {  /* reg : LSHI(reg,rc) */
			p->cost[sparc_reg_NT] = c + 0;
			p->rule.sparc_reg = 78;
			sparc_closure_reg(p, c + 0);
		}
		break;
	case 342:  /* LSHU */
		assert(l && r);
		c = l->cost[sparc_reg_NT] + r->cost[sparc_rc_NT] + 1;
		if (c + 0 < p->cost[sparc_reg_NT]) {  /* reg : LSHU(reg,rc) */
			p->cost[sparc_reg_NT] = c + 0;
			p->rule.sparc_reg = 79;
			sparc_closure_reg(p, c + 0);
		}
		break;
	case 546:  /* LTD */
		{
			static struct sparc_state z = { 546, 0, 0,
				{	0,
					0x7fff,
					0x7fff,
					0x7fff,
					0x7fff,
					0x7fff,
					0x7fff,
					0x7fff,
				},{
					0,
					0,
					0,
					0,
					0,
					0,
					0,
				}
			};
			return (int)&z;
		}
	case 545:  /* LTF */
		{
			static struct sparc_state z = { 545, 0, 0,
				{	0,
					0x7fff,
					0x7fff,
					0x7fff,
					0x7fff,
					0x7fff,
					0x7fff,
					0x7fff,
				},{
					0,
					0,
					0,
					0,
					0,
					0,
					0,
				}
			};
			return (int)&z;
		}
	case 549:  /* LTI */
		assert(l && r);
		c = l->cost[sparc_reg_NT] + r->cost[sparc_rc_NT] + 1;
		if (c + 0 < p->cost[sparc_stmt_NT]) {  /* stmt : LTI(reg,rc) */
			p->cost[sparc_stmt_NT] = c + 0;
			p->rule.sparc_stmt = 15;
		}
		break;
	case 550:  /* LTU */
		assert(l && r);
		c = l->cost[sparc_reg_NT] + r->cost[sparc_rc_NT] + 1;
		if (c + 0 < p->cost[sparc_stmt_NT]) {  /* stmt : LTU(reg,rc) */
			p->cost[sparc_stmt_NT] = c + 0;
			p->rule.sparc_stmt = 19;
		}
		break;
	case 357:  /* MODI */
		assert(l && r);
		c = l->cost[sparc_reg_NT] + r->cost[sparc_reg_NT] + 1;
		if (c + 0 < p->cost[sparc_reg_NT]) {  /* reg : MODI(reg,reg) */
			p->cost[sparc_reg_NT] = c + 0;
			p->rule.sparc_reg = 55;
			sparc_closure_reg(p, c + 0);
		}
		break;
	case 358:  /* MODU */
		assert(l && r);
		c = l->cost[sparc_reg_NT] + r->cost[sparc_reg_NT] + 1;
		if (c + 0 < p->cost[sparc_reg_NT]) {  /* reg : MODU(reg,reg) */
			p->cost[sparc_reg_NT] = c + 0;
			p->rule.sparc_reg = 56;
			sparc_closure_reg(p, c + 0);
		}
		break;
	case 466:  /* MULD */
		assert(l && r);
		c = l->cost[sparc_reg_NT] + r->cost[sparc_reg_NT] + 1;
		if (c + 0 < p->cost[sparc_reg_NT]) {  /* reg : MULD(reg,reg) */
			p->cost[sparc_reg_NT] = c + 0;
			p->rule.sparc_reg = 31;
			sparc_closure_reg(p, c + 0);
		}
		break;
	case 465:  /* MULF */
		assert(l && r);
		c = l->cost[sparc_reg_NT] + r->cost[sparc_reg_NT] + 1;
		if (c + 0 < p->cost[sparc_reg_NT]) {  /* reg : MULF(reg,reg) */
			p->cost[sparc_reg_NT] = c + 0;
			p->rule.sparc_reg = 30;
			sparc_closure_reg(p, c + 0);
		}
		break;
	case 469:  /* MULI */
		assert(l && r);
		c = l->cost[sparc_reg_NT] + r->cost[sparc_reg_NT] + 1;
		if (c + 0 < p->cost[sparc_reg_NT]) {  /* reg : MULI(reg,reg) */
			p->cost[sparc_reg_NT] = c + 0;
			p->rule.sparc_reg = 57;
			sparc_closure_reg(p, c + 0);
		}
		break;
	case 470:  /* MULU */
		assert(l && r);
		c = l->cost[sparc_reg_NT] + r->cost[sparc_reg_NT] + 1;
		if (c + 0 < p->cost[sparc_reg_NT]) {  /* reg : MULU(reg,reg) */
			p->cost[sparc_reg_NT] = c + 0;
			p->rule.sparc_reg = 58;
			sparc_closure_reg(p, c + 0);
		}
		break;
	case 562:  /* NED */
		{
			static struct sparc_state z = { 562, 0, 0,
				{	0,
					0x7fff,
					0x7fff,
					0x7fff,
					0x7fff,
					0x7fff,
					0x7fff,
					0x7fff,
				},{
					0,
					0,
					0,
					0,
					0,
					0,
					0,
				}
			};
			return (int)&z;
		}
	case 561:  /* NEF */
		{
			static struct sparc_state z = { 561, 0, 0,
				{	0,
					0x7fff,
					0x7fff,
					0x7fff,
					0x7fff,
					0x7fff,
					0x7fff,
					0x7fff,
				},{
					0,
					0,
					0,
					0,
					0,
					0,
					0,
				}
			};
			return (int)&z;
		}
	case 194:  /* NEGD */
		assert(l);
		c = l->cost[sparc_reg_NT] + 1;
		if (c + 0 < p->cost[sparc_reg_NT]) {  /* reg : NEGD(reg) */
			p->cost[sparc_reg_NT] = c + 0;
			p->rule.sparc_reg = 22;
			sparc_closure_reg(p, c + 0);
		}
		break;
	case 193:  /* NEGF */
		assert(l);
		c = l->cost[sparc_reg_NT] + 1;
		if (c + 0 < p->cost[sparc_reg_NT]) {  /* reg : NEGF(reg) */
			p->cost[sparc_reg_NT] = c + 0;
			p->rule.sparc_reg = 23;
			sparc_closure_reg(p, c + 0);
		}
		break;
	case 197:  /* NEGI */
		assert(l);
		c = l->cost[sparc_reg_NT] + 1;
		if (c + 0 < p->cost[sparc_reg_NT]) {  /* reg : NEGI(reg) */
			p->cost[sparc_reg_NT] = c + 0;
			p->rule.sparc_reg = 24;
			sparc_closure_reg(p, c + 0);
		}
		break;
	case 565:  /* NEI */
		assert(l && r);
		c = l->cost[sparc_reg_NT] + r->cost[sparc_rc_NT] + 1;
		if (c + 0 < p->cost[sparc_stmt_NT]) {  /* stmt : NEI(reg,rc) */
			p->cost[sparc_stmt_NT] = c + 0;
			p->rule.sparc_stmt = 12;
		}
		break;
	case 242:  /* RETD */
		assert(l);
		c = l->cost[sparc_reg_NT] + 1;
		if (c + 0 < p->cost[sparc_stmt_NT]) {  /* stmt : RETD(reg) */
			p->cost[sparc_stmt_NT] = c + 0;
			p->rule.sparc_stmt = 36;
		}
		break;
	case 241:  /* RETF */
		assert(l);
		c = l->cost[sparc_reg_NT] + 1;
		if (c + 0 < p->cost[sparc_stmt_NT]) {  /* stmt : RETF(reg) */
			p->cost[sparc_stmt_NT] = c + 0;
			p->rule.sparc_stmt = 35;
		}
		break;
	case 245:  /* RETI */
		assert(l);
		c = l->cost[sparc_reg_NT] + 1;
		if (c + 0 < p->cost[sparc_stmt_NT]) {  /* stmt : RETI(reg) */
			p->cost[sparc_stmt_NT] = c + 0;
			p->rule.sparc_stmt = 37;
		}
		break;
	case 248:  /* RETV */
		{
			static struct sparc_state z = { 248, 0, 0,
				{	0,
					1,	/* stmt: RETV */
					0x7fff,
					0x7fff,
					0x7fff,
					0x7fff,
					0x7fff,
					0x7fff,
				},{
					9,	/* stmt: RETV */
					0,
					0,
					0,
					0,
					0,
					0,
				}
			};
			return (int)&z;
		}
	case 373:  /* RSHI */
		assert(l && r);
		c = l->cost[sparc_reg_NT] + r->cost[sparc_rc_NT] + 1;
		if (c + 0 < p->cost[sparc_reg_NT]) {  /* reg : RSHI(reg,rc) */
			p->cost[sparc_reg_NT] = c + 0;
			p->rule.sparc_reg = 81;
			sparc_closure_reg(p, c + 0);
		}
		break;
	case 374:  /* RSHU */
		assert(l && r);
		c = l->cost[sparc_reg_NT] + r->cost[sparc_rc_NT] + 1;
		if (c + 0 < p->cost[sparc_reg_NT]) {  /* reg : RSHU(reg,rc) */
			p->cost[sparc_reg_NT] = c + 0;
			p->rule.sparc_reg = 80;
			sparc_closure_reg(p, c + 0);
		}
		break;
	case 322:  /* SUBD */
		assert(l && r);
		c = l->cost[sparc_reg_NT] + r->cost[sparc_reg_NT] + 1;
		if (c + 0 < p->cost[sparc_reg_NT]) {  /* reg : SUBD(reg,reg) */
			p->cost[sparc_reg_NT] = c + 0;
			p->rule.sparc_reg = 29;
			sparc_closure_reg(p, c + 0);
		}
		break;
	case 321:  /* SUBF */
		assert(l && r);
		c = l->cost[sparc_reg_NT] + r->cost[sparc_reg_NT] + 1;
		if (c + 0 < p->cost[sparc_reg_NT]) {  /* reg : SUBF(reg,reg) */
			p->cost[sparc_reg_NT] = c + 0;
			p->rule.sparc_reg = 28;
			sparc_closure_reg(p, c + 0);
		}
		break;
	case 325:  /* SUBI */
		assert(l && r);
		c = l->cost[sparc_reg_NT] + r->cost[sparc_rc_NT] + 1;
		if (c + 0 < p->cost[sparc_reg_NT]) {  /* reg : SUBI(reg,rc) */
			p->cost[sparc_reg_NT] = c + 0;
			p->rule.sparc_reg = 75;
			sparc_closure_reg(p, c + 0);
		}
		break;
	case 327:  /* SUBP */
		assert(l && r);
		c = l->cost[sparc_reg_NT] + r->cost[sparc_rc_NT] + 1;
		if (c + 0 < p->cost[sparc_reg_NT]) {  /* reg : SUBP(reg,rc) */
			p->cost[sparc_reg_NT] = c + 0;
			p->rule.sparc_reg = 76;
			sparc_closure_reg(p, c + 0);
		}
		break;
	case 326:  /* SUBU */
		assert(l && r);
		c = l->cost[sparc_reg_NT] + r->cost[sparc_rc_NT] + 1;
		if (c + 0 < p->cost[sparc_reg_NT]) {  /* reg : SUBU(reg,rc) */
			p->cost[sparc_reg_NT] = c + 0;
			p->rule.sparc_reg = 77;
			sparc_closure_reg(p, c + 0);
		}
		break;
	case 615:  /* VREGP */
		{
			static struct sparc_state z = { 615, 0, 0,
				{	0,
					0x7fff,
					0x7fff,
					0x7fff,
					0x7fff,
					0x7fff,
					0x7fff,
					0x7fff,
				},{
					0,
					0,
					0,
					0,
					0,
					0,
					0,
				}
			};
			return (int)&z;
		}
	default:
		CHECK(0, PANIC("sparc_state", "op=%d is bad\n", op))
	}
	return (int)p;
}

#ifdef STATE_LABEL
#ifdef __STDC__
int sparc_op_label(NODEPTR_TYPE);
int sparc_state_label(NODEPTR_TYPE);
NODEPTR_TYPE sparc_child(NODEPTR_TYPE, int);
NODEPTR_TYPE *sparc_kids(NODEPTR_TYPE, int, NODEPTR_TYPE[]);
static void sparc_label1(NODEPTR_TYPE);
int sparc_label(NODEPTR_TYPE);
#else
int sparc_op_label();
int sparc_state_label();
NODEPTR_TYPE sparc_child();
NODEPTR_TYPE *sparc_kids();
static void sparc_label1();
int sparc_label();
#endif

static void sparc_label1(p) NODEPTR_TYPE p; {
	CHECK(p, PANIC("Null tree in sparc_label\n"))
	switch (sparc_arity[OP_LABEL(p)]) {
	case 0:
		STATE_LABEL(p) = sparc_state(OP_LABEL(p), 0, 0);
		break;
	case 1:
		sparc_label1(LEFT_CHILD(p));
		STATE_LABEL(p) = sparc_state(OP_LABEL(p), STATE_LABEL(LEFT_CHILD(p)), 0);
		break;
	case 2:
		sparc_label1(LEFT_CHILD(p));
		sparc_label1(RIGHT_CHILD(p));
		STATE_LABEL(p) = sparc_state(OP_LABEL(p), STATE_LABEL(LEFT_CHILD(p)), STATE_LABEL(RIGHT_CHILD(p)));
		break;
	}
}

int sparc_label(p) NODEPTR_TYPE p; {
	sparc_label1(p);
	return ((struct sparc_state *)STATE_LABEL(p))->rule.sparc_stmt ? STATE_LABEL(p) : 0;
}

NODEPTR_TYPE *sparc_kids(p, eruleno, kids) NODEPTR_TYPE p, kids[]; {
	CHECK(p, PANIC("Null tree in sparc_kids\n"))
	switch (eruleno) {
	case 1:  /* acon: ADDRGP */
	case 3:  /* addr: ADDRFP */
	case 4:  /* addr: ADDRLP */
	case 11:  /* reg: ADDRGP */
	case 43:  /* stmt: LABELV */
	case 44:  /* stmt: RETV */
	case 49:  /* con: CNSTI */
	case 50:  /* con: CNSTP */
	case 51:  /* con: CNSTU */
	case 52:  /* con: CNSTC */
	case 53:  /* con: CNSTS */
	case 54:  /* con: I0I */
	case 55:  /* con: I1I */
	case 56:  /* con: I2I */
	case 57:  /* con: I3I */
	case 91:  /* reg: I0I */
	case 98:  /* reg: INDIRF(VREGP) */
	case 99:  /* reg: INDIRD(VREGP) */
	case 100:  /* reg: INDIRI(VREGP) */
	case 101:  /* reg: INDIRP(VREGP) */
	case 102:  /* reg: INDIRC(VREGP) */
	case 103:  /* reg: INDIRS(VREGP) */
		break;
	case 18:  /* reg: CVCI(INDIRC(addr)) */
	case 20:  /* reg: CVCU(INDIRC(addr)) */
	case 26:  /* reg: CVSI(INDIRS(addr)) */
	case 28:  /* reg: CVSU(INDIRS(addr)) */
		kids[0] = LEFT_CHILD(LEFT_CHILD(p));
		break;
	case 12:  /* reg: BCOMU(reg) */
	case 15:  /* reg: CALLD(ar) */
	case 16:  /* reg: CALLF(ar) */
	case 17:  /* reg: CALLI(ar) */
	case 19:  /* reg: CVCI(reg) */
	case 21:  /* reg: CVCU(reg) */
	case 22:  /* reg: CVDF(reg) */
	case 23:  /* reg: CVDI(reg) */
	case 24:  /* reg: CVFD(reg) */
	case 25:  /* reg: CVID(reg) */
	case 27:  /* reg: CVSI(reg) */
	case 29:  /* reg: CVSU(reg) */
	case 30:  /* reg: LOADD(reg) */
	case 31:  /* reg: LOADF(reg) */
	case 32:  /* reg: NEGD(reg) */
	case 33:  /* reg: NEGF(reg) */
	case 34:  /* reg: NEGI(reg) */
	case 36:  /* stmt: ARGD(reg) */
	case 37:  /* stmt: ARGF(reg) */
	case 40:  /* stmt: CALLV(ar) */
	case 41:  /* stmt: JUMPV(acon) */
	case 42:  /* stmt: JUMPV(addr) */
	case 70:  /* reg: CVIC(reg) */
	case 71:  /* reg: CVIS(reg) */
	case 72:  /* reg: CVIU(reg) */
	case 73:  /* reg: CVUC(reg) */
	case 74:  /* reg: CVUS(reg) */
	case 75:  /* reg: CVUI(reg) */
	case 76:  /* reg: CVPU(reg) */
	case 77:  /* reg: CVUP(reg) */
	case 78:  /* reg: INDIRB(reg) */
	case 79:  /* reg: LOADC(reg) */
	case 80:  /* reg: LOADS(reg) */
	case 81:  /* reg: LOADI(reg) */
	case 82:  /* reg: LOADP(reg) */
	case 83:  /* reg: LOADU(reg) */
	case 84:  /* reg: LOADB(reg) */
	case 92:  /* reg: INDIRF(addr) */
	case 93:  /* reg: INDIRD(addr) */
	case 94:  /* reg: INDIRI(addr) */
	case 95:  /* reg: INDIRP(addr) */
	case 96:  /* reg: INDIRC(addr) */
	case 97:  /* reg: INDIRS(addr) */
	case 114:  /* stmt: ARGI(reg) */
	case 115:  /* stmt: ARGP(reg) */
	case 128:  /* stmt: RETF(reg) */
	case 129:  /* stmt: RETD(reg) */
	case 130:  /* stmt: RETI(reg) */
		kids[0] = LEFT_CHILD(p);
		break;
	case 13:  /* reg: BXORU(reg,BCOMU(rc)) */
	case 66:  /* reg: BANDU(reg,BCOMU(rc)) */
	case 67:  /* reg: BORU(reg,BCOMU(rc)) */
		kids[0] = LEFT_CHILD(p);
		kids[1] = LEFT_CHILD(RIGHT_CHILD(p));
		break;
	case 14:  /* reg: BXORU(reg,rc) */
	case 38:  /* stmt: ASGNB(reg,reg) */
	case 39:  /* stmt: CALLB(ar,reg) */
	case 46:  /* addr: ADDI(reg,rc) */
	case 47:  /* addr: ADDP(reg,rc) */
	case 48:  /* addr: ADDU(reg,rc) */
	case 58:  /* reg: ADDF(reg,reg) */
	case 59:  /* reg: ADDD(reg,reg) */
	case 60:  /* reg: SUBF(reg,reg) */
	case 61:  /* reg: SUBD(reg,reg) */
	case 62:  /* reg: MULF(reg,reg) */
	case 63:  /* reg: MULD(reg,reg) */
	case 64:  /* reg: DIVF(reg,reg) */
	case 65:  /* reg: DIVD(reg,reg) */
	case 68:  /* reg: BANDU(reg,rc) */
	case 69:  /* reg: BORU(reg,rc) */
	case 85:  /* reg: DIVI(reg,reg) */
	case 86:  /* reg: DIVU(reg,reg) */
	case 87:  /* reg: MODI(reg,reg) */
	case 88:  /* reg: MODU(reg,reg) */
	case 89:  /* reg: MULI(reg,reg) */
	case 90:  /* reg: MULU(reg,reg) */
	case 104:  /* stmt: EQI(reg,rc) */
	case 105:  /* stmt: NEI(reg,rc) */
	case 106:  /* stmt: GTI(reg,rc) */
	case 107:  /* stmt: GEI(reg,rc) */
	case 108:  /* stmt: LTI(reg,rc) */
	case 109:  /* stmt: LEI(reg,rc) */
	case 110:  /* stmt: GTU(reg,rc) */
	case 111:  /* stmt: GEU(reg,rc) */
	case 112:  /* stmt: LTU(reg,rc) */
	case 113:  /* stmt: LEU(reg,rc) */
	case 116:  /* stmt: ASGNF(addr,reg) */
	case 117:  /* stmt: ASGND(addr,reg) */
	case 118:  /* stmt: ASGNI(addr,reg) */
	case 119:  /* stmt: ASGNP(addr,reg) */
	case 120:  /* stmt: ASGNC(addr,reg) */
	case 121:  /* stmt: ASGNS(addr,reg) */
	case 131:  /* reg: ADDI(reg,rc) */
	case 132:  /* reg: ADDP(reg,rc) */
	case 133:  /* reg: ADDU(reg,rc) */
	case 134:  /* reg: SUBI(reg,rc) */
	case 135:  /* reg: SUBP(reg,rc) */
	case 136:  /* reg: SUBU(reg,rc) */
	case 137:  /* reg: LSHI(reg,rc) */
	case 138:  /* reg: LSHU(reg,rc) */
	case 139:  /* reg: RSHU(reg,rc) */
	case 140:  /* reg: RSHI(reg,rc) */
		kids[0] = LEFT_CHILD(p);
		kids[1] = RIGHT_CHILD(p);
		break;
	case 122:  /* stmt: ASGNF(VREGP,reg) */
	case 123:  /* stmt: ASGND(VREGP,reg) */
	case 124:  /* stmt: ASGNI(VREGP,reg) */
	case 125:  /* stmt: ASGNP(VREGP,reg) */
	case 126:  /* stmt: ASGNC(VREGP,reg) */
	case 127:  /* stmt: ASGNS(VREGP,reg) */
		kids[0] = RIGHT_CHILD(p);
		break;
	case 2:  /* acon: con */
	case 5:  /* addr: acon */
	case 6:  /* addr: reg */
	case 7:  /* ar: acon */
	case 8:  /* ar: reg */
	case 9:  /* rc: con */
	case 10:  /* rc: reg */
	case 35:  /* reg: con */
	case 45:  /* stmt: reg */
		kids[0] = p;
		break;
	default:
		CHECK(0, PANIC("Bad external rule number %d in sparc_kids\n", eruleno))
	}
	return kids;
}
int sparc_op_label(p) NODEPTR_TYPE p; {
	CHECK(p, PANIC("Null tree in sparc_op_label\n"));
	return OP_LABEL(p);
}

int sparc_state_label(p) NODEPTR_TYPE p; {
	CHECK(p, PANIC("Null tree in sparc_state_label\n"));
	return STATE_LABEL(p);
}

NODEPTR_TYPE sparc_child(p, index) NODEPTR_TYPE p; {
	CHECK(p, PANIC("Null tree in sparc_child\n"));
	switch (index) {
	case 0:	return LEFT_CHILD(p);
	case 1:	return RIGHT_CHILD(p);
	}
	CHECK(0, PANIC("Bad index %d in sparc_child\n", index));
	return 0;
}
#endif

static struct rule rules[] = {
/*   0 */  { 0, "%"},
/*   1 */  { 0, "%a" },  /* acon: ADDRGP */
/*   2 */  { 0, "%0" },  /* acon: con */
/*   3 */  { 0, "[%%%fp+%a]" },  /* addr: ADDRFP */
/*   4 */  { 0, "[%%%fp+%a]" },  /* addr: ADDRLP */
/*   5 */  { 0, "[%0]" },  /* addr: acon */
/*   6 */  { 0, "[%%%0]" },  /* addr: reg */
/*   7 */  { 0, "%0" },  /* ar: acon */
/*   8 */  { 0, "%%%0" },  /* ar: reg */
/*   9 */  { 0, "%0" },  /* rc: con */
/*  10 */  { 0, "%%%0" },  /* rc: reg */
/*  11 */  { 1, "set %a,%%%c\n" },  /* reg: ADDRGP */
/*  12 */  { 1, "not %%%0,%%%c\n" },  /* reg: BCOMU(reg) */
/*  13 */  { 1, "xnor %%%0,%%%1,%%%c\n" },  /* reg: BXORU(reg,BCOMU(rc)) */
/*  14 */  { 1, "xor %%%0,%%%1,%%%c\n" },  /* reg: BXORU(reg,rc) */
/*  15 */  { 1, "call %0; nop\n" },  /* reg: CALLD(ar) */
/*  16 */  { 1, "call %0; nop\n" },  /* reg: CALLF(ar) */
/*  17 */  { 1, "call %0; nop\n" },  /* reg: CALLI(ar) */
/*  18 */  { 1, "ldsb %0,%%%c\n" },  /* reg: CVCI(INDIRC(addr)) */
/*  19 */  { 1, "sll %%%0,24,%%g1; sra %%g1,24,%%%c\n" },  /* reg: CVCI(reg) */
/*  20 */  { 1, "ldub %0,%%%c\n" },  /* reg: CVCU(INDIRC(addr)) */
/*  21 */  { 1, "and %%%0,0xff,%%%c\n" },  /* reg: CVCU(reg) */
/*  22 */  { 1, "fdtos %%f%0,%%f%c\n" },  /* reg: CVDF(reg) */
/*  23 */  { 1, "fdtoi %%f%0,%%f0; st %%f0,[%%sp+64]; ld [%%sp+64],%%%c\n" },  /* reg: CVDI(reg) */
/*  24 */  { 1, "fstod %%f%0,%%f%c\n" },  /* reg: CVFD(reg) */
/*  25 */  { 1, "st %%%0,[%%sp+64]; ld [%%sp+64],%%f%c; fitod %%f%c,%%f%c\n" },  /* reg: CVID(reg) */
/*  26 */  { 1, "ldsh %0,%%%c\n" },  /* reg: CVSI(INDIRS(addr)) */
/*  27 */  { 1, "sll %%%0,16,%%g1; sra %%g1,16,%%%c\n" },  /* reg: CVSI(reg) */
/*  28 */  { 1, "lduh %0,%%%c\n" },  /* reg: CVSU(INDIRS(addr)) */
/*  29 */  { 1, "set 0xffff,%%g1; and %%%0,%%g1,%%%c\n" },  /* reg: CVSU(reg) */
/*  30 */  { 1, "# LOADD\n" },  /* reg: LOADD(reg) */
/*  31 */  { 1, "fmovs %%%0,%%%c\n" },  /* reg: LOADF(reg) */
/*  32 */  { 1, "# NEGD\n" },  /* reg: NEGD(reg) */
/*  33 */  { 1, "fnegs %%f%0,%%f%c\n" },  /* reg: NEGF(reg) */
/*  34 */  { 1, "neg %%%0,%%%c\n" },  /* reg: NEGI(reg) */
/*  35 */  { 1, "set %0,%%%c\n" },  /* reg: con */
/*  36 */  { 1, "# ARGD\n" },  /* stmt: ARGD(reg) */
/*  37 */  { 1, "# ARGF\n" },  /* stmt: ARGF(reg) */
/*  38 */  { 1, "# ASGNB\n" },  /* stmt: ASGNB(reg,reg) */
/*  39 */  { 1, "call %0; st %%%1,[%%sp+64]\n" },  /* stmt: CALLB(ar,reg) */
/*  40 */  { 1, "call %0; nop\n" },  /* stmt: CALLV(ar) */
/*  41 */  { 1, "ba %0; nop\n" },  /* stmt: JUMPV(acon) */
/*  42 */  { 1, "jmp %%%0; nop\n" },  /* stmt: JUMPV(addr) */
/*  43 */  { 1, "%a:\n" },  /* stmt: LABELV */
/*  44 */  { 1, "# ret\n" },  /* stmt: RETV */
/*  45 */  { 0, "" },  /* stmt: reg */
/*  46 */  { 0, "[%%%0+%1]" },  /* addr: ADDI(reg,rc) */
/*  47 */  { 0, "[%%%0+%1]" },  /* addr: ADDP(reg,rc) */
/*  48 */  { 0, "[%%%0+%1]" },  /* addr: ADDU(reg,rc) */
/*  49 */  { 0, "%a" },  /* con: CNSTI */
/*  50 */  { 0, "%a" },  /* con: CNSTP */
/*  51 */  { 0, "%a" },  /* con: CNSTU */
/*  52 */  { 0, "%a" },  /* con: CNSTC */
/*  53 */  { 0, "%a" },  /* con: CNSTS */
/*  54 */  { 0, "%a" },  /* con: I0I */
/*  55 */  { 0, "%a" },  /* con: I1I */
/*  56 */  { 0, "%a" },  /* con: I2I */
/*  57 */  { 0, "%a" },  /* con: I3I */
/*  58 */  { 1, "adds %%f%0,%%f%1,%%f%c\n" },  /* reg: ADDF(reg,reg) */
/*  59 */  { 1, "addd %%f%0,%%f%1,%%f%c\n" },  /* reg: ADDD(reg,reg) */
/*  60 */  { 1, "subs %%f%0,%%f%1,%%f%c\n" },  /* reg: SUBF(reg,reg) */
/*  61 */  { 1, "subd %%f%0,%%f%1,%%f%c\n" },  /* reg: SUBD(reg,reg) */
/*  62 */  { 1, "muls %%f%0,%%f%1,%%f%c\n" },  /* reg: MULF(reg,reg) */
/*  63 */  { 1, "muld %%f%0,%%f%1,%%f%c\n" },  /* reg: MULD(reg,reg) */
/*  64 */  { 1, "divs %%f%0,%%f%1,%%f%c\n" },  /* reg: DIVF(reg,reg) */
/*  65 */  { 1, "divd %%f%0,%%f%1,%%f%c\n" },  /* reg: DIVD(reg,reg) */
/*  66 */  { 1, "andn %%%0,%%%1,%%%c\n" },  /* reg: BANDU(reg,BCOMU(rc)) */
/*  67 */  { 1, "orn %%%0,%%%1,%%%c\n" },  /* reg: BORU(reg,BCOMU(rc)) */
/*  68 */  { 1, "and %%%0,%%%1,%%%c\n" },  /* reg: BANDU(reg,rc) */
/*  69 */  { 1, "or %%%0,%%%1,%%%c\n" },  /* reg: BORU(reg,rc) */
/*  70 */  { 1, "mov %%%0,%%%c\n" },  /* reg: CVIC(reg) */
/*  71 */  { 1, "mov %%%0,%%%c\n" },  /* reg: CVIS(reg) */
/*  72 */  { 1, "mov %%%0,%%%c\n" },  /* reg: CVIU(reg) */
/*  73 */  { 1, "mov %%%0,%%%c\n" },  /* reg: CVUC(reg) */
/*  74 */  { 1, "mov %%%0,%%%c\n" },  /* reg: CVUS(reg) */
/*  75 */  { 1, "mov %%%0,%%%c\n" },  /* reg: CVUI(reg) */
/*  76 */  { 1, "mov %%%0,%%%c\n" },  /* reg: CVPU(reg) */
/*  77 */  { 1, "mov %%%0,%%%c\n" },  /* reg: CVUP(reg) */
/*  78 */  { 1, "mov %%%0,%%%c\n" },  /* reg: INDIRB(reg) */
/*  79 */  { 1, "mov %%%0,%%%c\n" },  /* reg: LOADC(reg) */
/*  80 */  { 1, "mov %%%0,%%%c\n" },  /* reg: LOADS(reg) */
/*  81 */  { 1, "mov %%%0,%%%c\n" },  /* reg: LOADI(reg) */
/*  82 */  { 1, "mov %%%0,%%%c\n" },  /* reg: LOADP(reg) */
/*  83 */  { 1, "mov %%%0,%%%c\n" },  /* reg: LOADU(reg) */
/*  84 */  { 1, "mov %%%0,%%%c\n" },  /* reg: LOADB(reg) */
/*  85 */  { 1, "mov %%%1,%%o1; call .div,2; mov %%%0,%%o0; mov %%o0,%%%c\n" },  /* reg: DIVI(reg,reg) */
/*  86 */  { 1, "mov %%%1,%%o1; call .udiv,2; mov %%%0,%%o0; mov %%o0,%%%c\n" },  /* reg: DIVU(reg,reg) */
/*  87 */  { 1, "mov %%%1,%%o1; call .rem,2; mov %%%0,%%o0; mov %%o0,%%%c\n" },  /* reg: MODI(reg,reg) */
/*  88 */  { 1, "mov %%%1,%%o1; call .urem,2; mov %%%0,%%o0; mov %%o0,%%%c\n" },  /* reg: MODU(reg,reg) */
/*  89 */  { 1, "mov %%%1,%%o1; call .mul,2; mov %%%0,%%o0; mov %%o0,%%%c\n" },  /* reg: MULI(reg,reg) */
/*  90 */  { 1, "mov %%%1,%%o1; call .umul,2; mov %%%0,%%o0; mov %%o0,%%%c\n" },  /* reg: MULU(reg,reg) */
/*  91 */  { 1, "# reg\n" },  /* reg: I0I */
/*  92 */  { 1, "ld %0,%%f%c\n" },  /* reg: INDIRF(addr) */
/*  93 */  { 1, "ldd %0,%%f%c\n" },  /* reg: INDIRD(addr) */
/*  94 */  { 1, "ld %0,%%%c\n" },  /* reg: INDIRI(addr) */
/*  95 */  { 1, "ld %0,%%%c\n" },  /* reg: INDIRP(addr) */
/*  96 */  { 1, "ldsb %0,%%%c\n" },  /* reg: INDIRC(addr) */
/*  97 */  { 1, "ldsh %0,%%%c\n" },  /* reg: INDIRS(addr) */
/*  98 */  { 1, "# reg\n" },  /* reg: INDIRF(VREGP) */
/*  99 */  { 1, "# reg\n" },  /* reg: INDIRD(VREGP) */
/* 100 */  { 1, "# reg\n" },  /* reg: INDIRI(VREGP) */
/* 101 */  { 1, "# reg\n" },  /* reg: INDIRP(VREGP) */
/* 102 */  { 1, "# reg\n" },  /* reg: INDIRC(VREGP) */
/* 103 */  { 1, "# reg\n" },  /* reg: INDIRS(VREGP) */
/* 104 */  { 1, "cmp %%%0,%1; be %a; nop\n" },  /* stmt: EQI(reg,rc) */
/* 105 */  { 1, "cmp %%%0,%1; bne %a; nop\n" },  /* stmt: NEI(reg,rc) */
/* 106 */  { 1, "cmp %%%0,%1; bg %a; nop\n" },  /* stmt: GTI(reg,rc) */
/* 107 */  { 1, "cmp %%%0,%1; bge %a; nop\n" },  /* stmt: GEI(reg,rc) */
/* 108 */  { 1, "cmp %%%0,%1; bl %a; nop\n" },  /* stmt: LTI(reg,rc) */
/* 109 */  { 1, "cmp %%%0,%1; ble %a; nop\n" },  /* stmt: LEI(reg,rc) */
/* 110 */  { 1, "cmp %%%0,%1; bgu %a; nop\n" },  /* stmt: GTU(reg,rc) */
/* 111 */  { 1, "cmp %%%0,%1; bgeu %a; nop\n" },  /* stmt: GEU(reg,rc) */
/* 112 */  { 1, "cmp %%%0,%1; blu %a; nop\n" },  /* stmt: LTU(reg,rc) */
/* 113 */  { 1, "cmp %%%0,%1; bleu %a; nop\n" },  /* stmt: LEU(reg,rc) */
/* 114 */  { 1, "st %%%0,[%%sp+4*%c+68]\n" },  /* stmt: ARGI(reg) */
/* 115 */  { 1, "st %%%0,[%%sp+4*%c+68]\n" },  /* stmt: ARGP(reg) */
/* 116 */  { 1, "st %%f%1,%0\n" },  /* stmt: ASGNF(addr,reg) */
/* 117 */  { 1, "std %%f%1,%0\n" },  /* stmt: ASGND(addr,reg) */
/* 118 */  { 1, "st %%%1,%0\n" },  /* stmt: ASGNI(addr,reg) */
/* 119 */  { 1, "st %%%1,%0\n" },  /* stmt: ASGNP(addr,reg) */
/* 120 */  { 1, "stb %%%1,%0\n" },  /* stmt: ASGNC(addr,reg) */
/* 121 */  { 1, "sth %%%1,%0\n" },  /* stmt: ASGNS(addr,reg) */
/* 122 */  { 1, "# nop\n" },  /* stmt: ASGNF(VREGP,reg) */
/* 123 */  { 1, "# nop\n" },  /* stmt: ASGND(VREGP,reg) */
/* 124 */  { 1, "# nop\n" },  /* stmt: ASGNI(VREGP,reg) */
/* 125 */  { 1, "# nop\n" },  /* stmt: ASGNP(VREGP,reg) */
/* 126 */  { 1, "# nop\n" },  /* stmt: ASGNC(VREGP,reg) */
/* 127 */  { 1, "# nop\n" },  /* stmt: ASGNS(VREGP,reg) */
/* 128 */  { 1, "# ret\n" },  /* stmt: RETF(reg) */
/* 129 */  { 1, "# ret\n" },  /* stmt: RETD(reg) */
/* 130 */  { 1, "# ret\n" },  /* stmt: RETI(reg) */
/* 131 */  { 1, "add %%%0,%1,%%%c\n" },  /* reg: ADDI(reg,rc) */
/* 132 */  { 1, "add %%%0,%1,%%%c\n" },  /* reg: ADDP(reg,rc) */
/* 133 */  { 1, "add %%%0,%1,%%%c\n" },  /* reg: ADDU(reg,rc) */
/* 134 */  { 1, "sub %%%0,%1,%%%c\n" },  /* reg: SUBI(reg,rc) */
/* 135 */  { 1, "sub %%%0,%1,%%%c\n" },  /* reg: SUBP(reg,rc) */
/* 136 */  { 1, "sub %%%0,%1,%%%c\n" },  /* reg: SUBU(reg,rc) */
/* 137 */  { 1, "sll %%%0,%1,%%%c\n" },  /* reg: LSHI(reg,rc) */
/* 138 */  { 1, "sll %%%0,%1,%%%c\n" },  /* reg: LSHU(reg,rc) */
/* 139 */  { 1, "srl %%%0,%1,%%%c\n" },  /* reg: RSHU(reg,rc) */
/* 140 */  { 1, "sra %%%0,%1,%%%c\n" },  /* reg: RSHI(reg,rc) */
};

#include "pseudos.c"
#include "target.c"
